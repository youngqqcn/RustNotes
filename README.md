
# **Rust ä¹‹æ—…**


## æ‚è°ˆ

ç›®å‰, Ruståœ¨å›½å†…åº”ç”¨ä¸å¹¿, Rustå¼€å‘äººå‘˜ä¹Ÿå¾ˆå°‘, ä¸­æ–‡æŠ€æœ¯æ–‡æ¡£ä¸å¤š. Rustçš„å­¦ä¹ éš¾åº¦ä¹Ÿæ¯”è¾ƒå¤§, æ¯”å­¦ä¹ C++çš„éš¾åº¦å¤§. Rustå€Ÿé‰´äº†å¾ˆå¤šç¼–ç¨‹è¯­è¨€çš„æœ‰ç‚¹, åŒ…æ‹¬C++, Java, Golang, Python, JavaScript, Haskell, ...ç­‰ç­‰, å…¶ä¸­å€Ÿé‰´C++å’ŒGolangçš„æˆåˆ†æ˜¯æœ€å¤šçš„. 

åœ¨åŒºå—é“¾é¢†åŸŸ, å¾ˆå¤šæ–°çš„åŒºå—é“¾é¡¹ç›®éƒ½é€‰æ‹©ç”¨Rustä½œä¸ºç¬¬ä¸€å¼€å‘è¯­è¨€, ä¸»è¦æ˜¯å‡ºäºå®‰å…¨å’Œæ€§èƒ½æ–¹é¢è€ƒè™‘. 

ä¸ç®¡é€‰æ‹©å“ªç§ç¼–ç¨‹è¯­è¨€,è¦æƒ³å†™å‡ºå®‰å…¨,ç¨³å®š,é«˜æ€§èƒ½,ä»£ç å¯è¯»æ€§å¥½,å¯ç»´æŠ¤æ€§é«˜çš„é¡¹ç›®,éƒ½æ˜¯éœ€è¦å¤§é‡çš„ç»éªŒç§¯ç´¯. å†°å†»ä¸‰å°º,éä¸€æ—¥ä¹‹å¯’. 

ç¼–ç¨‹è¯­è¨€æ²¡æœ‰ä¼˜åŠ£ä¹‹åˆ†, ä¸åŒçš„ç¼–ç¨‹è¯­è¨€æœ‰å„è‡ªæ‰€é•¿, æœ‰å„è‡ªä¸åŒçš„é€‚ç”¨åœºæ™¯, æ‰€ä»¥, é€‰æ‹©å“ªç§ç¼–ç¨‹è¯­è¨€ä½œä¸ºé¡¹ç›®çš„ç¬¬ä¸€è¯­è¨€æ—¶, åº”å…·ä½“æƒ…å†µå…·ä½“åˆ†æ, ä¸èƒ½ç›²ç›®è¿·ä¿¡æŸç§ç¼–ç¨‹è¯­è¨€æˆ–æŸç§æŠ€æœ¯.

å­¦ä¹ ä¸€é—¨æŠ€æœ¯æ˜¯æœ‰æˆæœ¬çš„, éœ€è¦ä»˜å‡ºæ—¶é—´å’Œç²¾åŠ›. å°±åƒæŠ•èµ„, æ¯ä¸ªäººéƒ½æœ‰ä¸åŒçš„æŠ•èµ„ç†å¿µ. æœ‰äº›äººåšçŸ­æœŸæŠ•èµ„, ä¾‹å¦‚:å­¦ä¹ é‚£äº›çƒ­é—¨çš„æŠ€æœ¯ä½†æ˜¯æŠ€æœ¯æ›´æ–°éå¸¸å¿«,ä¸¤ä¸‰å¹´åå°±è¿‡æ—¶äº†; æœ‰äº›äººåšé•¿æœŸæŠ•èµ„, ä¾‹å¦‚: å­¦ä¹ é‚£äº›å°†æ¥ä¼šå¤§æœ‰å¯ä¸ºçš„æŠ€æœ¯,æˆ–è®¸æ˜¯äº”å¹´ååå¹´å. 

äººçš„æ—¶é—´å’Œç²¾åŠ›æ˜¯æœ‰é™çš„, åªèƒ½åœ¨æœ‰é™çš„æ—¶é—´é‡Œç”¨æœ‰é™çš„ç²¾åŠ›å­¦ä¹ é‚£äº›æœ€æœ‰æŠ•èµ„ä»·å€¼çš„ä¸œè¥¿. è¿™äº›æœ‰ä»·å€¼çš„ä¸œè¥¿ä¸€èˆ¬éƒ½æ˜¯æŠ½è±¡çš„, è€Œä¸æ˜¯å…·ä½“çš„.


äººå„æœ‰å¿—. ä¸è¦è½»æ˜“åšé‡å¤§å†³å®š, ä¹Ÿä¸è¦è½»æ˜“æ”¾å¼ƒé‡å¤§å†³å®š. æ›´ä¸è¦å› ä¸ºåˆ«äººçš„ä¸‰è¨€ä¸¤è¯­è€Œæ”¾å¼ƒ.

ç¥ Rustä¹‹æ—…,æ—…é€”æ„‰å¿«!

*2020-06-26 äºæ·±åœ³*


---




> - Rustå®˜æ–¹æ–‡æ¡£: https://doc.rust-lang.org/book/
> - Rustä¸­æ–‡æ–‡æ¡£: https://kaisery.github.io/trpl-zh-cn/
> - é€šè¿‡ä¾‹å­å­¦Rust(è‹±æ–‡): https://doc.rust-lang.org/stable/rust-by-example/
> - é€šè¿‡ä¾‹å­å­¦Rust(ä¸­æ–‡): https://rustwiki.org/zh-CN/rust-by-example/
> - Cargoæ–‡æ¡£: https://doc.rust-lang.org/cargo/




## ç¬¬1ç«   å…¥é—¨æŒ‡å—

### å®‰è£… Rust
- Linux , MacOSä¸Šå®‰è£…Rust
    ```shell
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```

- Windowså®‰è£…Rust
    > https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html#%E5%9C%A8-windows-%E4%B8%8A%E5%AE%89%E8%A3%85-rustup
    
    https://www.rust-lang.org/tools/install
    
- æ£€æŸ¥
    ```
    rustc --version
    ```

### Hello, World

- æ–°å»ºæ–‡ä»¶ `main.rs`
    ```rust
    fn main() {
        println!("Hello, world!");
    }
    ```

- ç¼–è¯‘
    ```
    rustc main.rs
    ```
- è¿è¡Œ 
    ```
    ./main
    ```

### Cargo çš„ä½¿ç”¨
Cargo æ˜¯ Rust çš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨, å¤§å¤šæ•° Rustacean ä»¬ä½¿ç”¨ Cargo æ¥ç®¡ç†ä»–ä»¬çš„ Rust é¡¹ç›®ï¼Œå› ä¸ºå®ƒå¯ä»¥ä¸ºä½ å¤„ç†å¾ˆå¤šä»»åŠ¡ï¼Œæ¯”å¦‚æ„å»ºä»£ç ã€ä¸‹è½½ä¾èµ–åº“å¹¶ç¼–è¯‘è¿™äº›åº“.

#### å¸¸ç”¨å‘½ä»¤
  
  - `cargo new xxx` :    æ–°å»ºäºŒè¿›åˆ¶crate
  - `cargo new xxx --lib` :  æ–°å»º lib crate
  - `cargo build`:  ç¼–è¯‘ä»£ç 
  - `cargo check`:  ç¼–è¯‘æ£€æŸ¥ä»£ç 
  - `cargo run` :  ç¼–è¯‘å¹¶è¿è¡Œ
  - `cargo build --release` :  ç¼–è¯‘releaseç‰ˆ
  - `cargo clean` : åˆ é™¤targetç›®å½•
  - `cargo test`: è¿è¡Œæµ‹è¯•ç”¨ä¾‹
  - `cargo update`: ä½¿ç”¨cargo.tomlè·å–æœ€æ–°ç‰ˆçš„crate, å¹¶å°†ç‰ˆæœ¬å·å†™å…¥Cargo.lockä¸­ä¿å­˜
  

#### Hello world
  
  ```
  cargo new helloworld

  cd helloworld

  cargo run

  ```

#### Cargoé…ç½®å›½å†…é•œåƒæº

cargoé»˜è®¤çš„æºåœ¨å›½å¤–, ä¸‹è½½é€Ÿåº¦å¾ˆæ…¢, å¯ä»¥æ¢æˆå›½å†…æº(ä¸­ç§‘å¤§)

åœ¨`~/.cargo/`ç›®å½•ä¸‹åˆ›å»ºæ–‡ä»¶`config`

```
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = 'ustc'
[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"
```

å†åœ¨`~/.bashrc`ä¸­æ·»åŠ æ·»åŠ ç¯å¢ƒå˜é‡

```
export RUSTUP_DIST_SERVER=https://mirrors.ustc.cn/rust-static
export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.cn/tust-static/rustup
```

ä½¿é…ç½®ç”Ÿæ•ˆ

`source ~/.bashrc`


#### Cargo å¸¸è§é—®é¢˜å¤„ç†
  
cargo runæ—¶é‡åˆ° `Blocking waiting for file lock on package cache` 
- æ–¹æ³•: åˆ é™¤ `~/.cargo/.package-cache`


## ç¬¬2ç«   ç¼–å†™ "çŒœçŒœçœ‹" æ¸¸æˆ


Cargo.lock: æ–‡ä»¶ç”¨äºä¿è¯æ‰€ç”¨çš„åº“çš„ç‰ˆæœ¬ä¸€è‡´, å½“æ‰§è¡Œ `cargo update`æ—¶ä½¿ç”¨cargo.tomlè·å–æœ€æ–°ç‰ˆçš„crate, å¹¶å°†ç‰ˆæœ¬å·å†™å…¥Cargo.lockä¸­ä¿å­˜


```rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // println!("Hello, world!");

    println!("æ¬¢è¿è¿›å…¥çŒœçŒœçœ‹!");
    println!("è¯·è¾“å…¥ä½ çŒœæµ‹çš„æ•°å­—:");

    let rand_num = rand::thread_rng().gen_range(1, 100);

   
    loop {

        let mut guess_num = String::new(); // å…³è”å‡½æ•°(associate function),  C++ä¸­çš„é™æ€æ–¹æ³•
        io::stdin().read_line(&mut guess_num).expect("è¯»å–é”™è¯¯!");
    
        // è¿™ç§æ–¹å¼, åœ¨è¾“å…¥æ— æ•ˆæ•°å­—æƒ…å†µä¸‹ä¼šå¯¼è‡´ç¨‹åºå´©æºƒé€€å‡º
        // let number: u32 = guess_num.trim().parse().expect("please input a number ");

        // ä½¿ç”¨ trim() å»æ‰ '\n'
        // ä½¿ç”¨ parse å°†å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º u32
        // ä½¿ç”¨ match å¯¹  parseè¿”å›çš„  Result<F, F::Err> è¿›è¡ŒåŒ¹é…å¤„ç†
        let number: u32 = match guess_num.trim().parse() {
            //å¤„ç†æ— æ•ˆè¾“å…¥
            Ok(num) => num,
            Err(err) => {
                println!("error:{}, please input right number", err);
                continue
            }
        };
    
        // è¿›è¡Œæ¨¡å¼åŒ¹é…
        match number.cmp(&rand_num) {
            Ordering::Less => println!("small"),
            Ordering::Greater => println!("big"),
            Ordering::Equal => {
                println!("yes");
                break;
            } 
        }
        

        /*
        // ä¹Ÿå¯ä»¥ä½¿ç”¨ä½¿ç”¨ if ... else  
        if number < rand_num {
            println!("small");
        } else if number == rand_num {
            println!("yes");
            break;
        } else {
            println!("big");
        }
        */

    }
}

```


## ç¬¬3ç«  å¸¸è§ç¼–ç¨‹æ¦‚å¿µ

### å˜é‡å’Œå¯å˜æ€§

åœ¨Rustä¸­å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„. å¦‚éœ€å¯å˜çš„å˜é‡, åœ¨å£°æ˜æ—¶è¦æŒ‡å®šä¸º`mut`.

```rust
let x = 666; // immutable
//x = 777; //é”™è¯¯, ä¸å¯ä¿®æ”¹ä¸å¯å˜å˜é‡çš„å€¼

let mut y = 666; // muttable
y = 777; //ok
```

### ä¸å¯å˜å˜é‡å’Œå¸¸é‡çš„åŒºåˆ«

- ä¸å…è®¸å¯¹å¸¸é‡ä½¿ç”¨`mut`
- ä½¿ç”¨ `const` å£°æ˜å¸¸é‡, è€Œä¸æ˜¯ `let`
- å£°æ˜å¸¸é‡æ—¶å¿…é¡»æ³¨æ˜ç±»å‹
- å¸¸é‡å¯ä»¥åœ¨ä»»ä½•ä½œç”¨äºä¸­å£°æ˜, åŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
- å¸¸é‡åªèƒ½è®¾ç½®ä¸ºå¸¸é‡è¡¨è¾¾å¼(å³ç¼–è¯‘æ—¶ç¡®å®šçš„ç»“æœ), æ‰€ä»¥ä¸èƒ½æ˜¯å‡½æ•°æˆ–å…¶ä»–åœ¨è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å‡ºç»“æœçš„å€¼
- å¸¸é‡çš„ç”Ÿå‘½å‘¨æœŸå’Œç¨‹åºç”Ÿå‘½å‘¨æœŸä¸€æ ·

```rust
const MAX_POINTS: u32 = 100000;
```


### éšè—(Shadowing)

éšè—å’Œ`mut`çš„åŒºåˆ«:
- éšè—åˆ›å»ºçš„æ˜¯ä¸€ä¸ªå…¨æ–°çš„å˜é‡,å¯ä»¥ä½¿ç”¨æ–°çš„ç±»å‹
- å¯ä»¥å¤ç”¨ç›¸åŒçš„å˜é‡åç§°


```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x); // 12

    let x = "x"; //éšè—
    // x = "hello";// error , xä»ç„¶æ˜¯ä¸å¯å˜çš„
}
```

### æ•°æ®ç±»å‹

Rustçš„æ•°æ®ç±»å‹åˆ†ä¸ºä¸¤å¤§ç±»: æ ‡é‡(scalar) å’Œ å¤åˆ(compound)

#### æ ‡é‡ç±»å‹

æ•´å‹

|æ•°å­—å­—é¢å€¼|	ä¾‹å­
|---------|-----------|
|Decimal (åè¿›åˆ¶) |	`98_222`
|Hex (åå…­è¿›åˆ¶)	| `0xff`
|Octal (å…«è¿›åˆ¶) |	`0o77`
|Binary (äºŒè¿›åˆ¶) |	`0b1111_0000`
|Byte (å•å­—èŠ‚å­—ç¬¦)(ä»…é™äºu8) | `b'A'`


```rust
let n = 120u8;
let n = 100000000; //é»˜è®¤æ˜¯ i32
let n: i64 = 100000000; 
let n = 100_000_000u32;
let n = b'a'; //97
let n = 0xFFu32; //255;
let n = 0o10; // 8
let n = 0b1111; // 15
```

>æ³¨æ„: åœ¨Rustä¸­, Debugæ¨¡å¼ä¸‹è‹¥å‘ç”Ÿæ•´å‹æº¢å‡º, ä¼šå¯¼è‡´panic. Releaseä¸ä¼šæ£€æµ‹æ•´å‹æº¢å‡º.


æµ®ç‚¹å‹

Rustæœ‰ä¸¤ç§æµ®ç‚¹ç±»å‹: `f32` å’Œ `f64`, Rustä¸­é»˜è®¤æµ®ç‚¹ç±»å‹æ˜¯ `f64`

```rust

let x = 5.50423; // é»˜è®¤æ˜¯ f64
let x: f32 = 9.1234; // f32

```

æ•°å€¼è¿ç®—

```rust
fn main() {
    // åŠ æ³•
    let sum = 5 + 10;

    // å‡æ³•
    let difference = 95.5 - 4.3;

    // ä¹˜æ³•
    let product = 4 * 30;

    // é™¤æ³•
    let quotient = 56.7 / 32.2;

    // å–ä½™
    let remainder = 43 % 5;
}
```


å¸ƒå°”ç±»å‹

Rustä¸­çš„å¸ƒå°”ç±»å‹: `bool`

```rust
let t = true;
let f: bool = false; // æ˜¾å¼æŒ‡å®šç±»å‹æ³¨è§£
```

å­—ç¬¦ç±»å‹

Rustä¸­çš„`char`å 4ä¸ªå­—èŠ‚, ä»£è¡¨äº†ä¸€ä¸ª Unicodeæ ‡é‡.
Unicode æ ‡é‡å€¼åŒ…å«ä» U+0000 åˆ° U+D7FF å’Œ U+E000 åˆ° U+10FFFF åœ¨å†…çš„å€¼ã€‚

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let ch = 'å›½';
    let jp = 'ã';
    let gs = 'âˆ®';
    let sum = 'âˆ‘'; 
    let ko = 'ã„¶'; 


    // ä½¿ç”¨emoji https://emojipedia.org/
    let football = 'âš½';
    let smail = 'ğŸ˜Š'; //emoji
    let laughing_crying = 'ğŸ˜‚'; //emoji
}
```



å¤åˆç±»å‹: å…ƒç»„(tuple) å’Œ æ•°ç»„(array)

å…ƒç»„ç±»å‹
å…ƒç»„æ˜¯ä¸€ä¸ªå°†å¤šä¸ªå…¶ä»–ç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªå¤åˆç±»å‹çš„ä¸»è¦æ–¹å¼ã€‚å…ƒç»„é•¿åº¦å›ºå®šï¼šä¸€æ—¦å£°æ˜ï¼Œå…¶é•¿åº¦ä¸ä¼šå¢å¤§æˆ–ç¼©å°ã€‚

```rust

let tup: (i32, f64, u8) = (500, 6.4, 1);
println("{}", tup.0);
println!("{}", tup.1);

```


æ•°ç»„ç±»å‹
æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒ, Rust ä¸­çš„æ•°ç»„æ˜¯å›ºå®šé•¿åº¦çš„,ä¸€æ—¦å£°æ˜ï¼Œå®ƒä»¬çš„é•¿åº¦ä¸èƒ½å¢é•¿æˆ–ç¼©å°ã€‚

```rust
let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];//ç­‰æ•ˆäº [3, 3, 3, 3, 3]

println!("{}", a[0]);
// println!("{}", a[1000]); //ç¼–è¯‘é”™è¯¯!


let index = 10000;
println!("{}", a[index]); //ç¼–è¯‘é€šè¿‡, ä½†æ˜¯è¿è¡Œæ—¶panic


```


### å‡½æ•°

å› ä¸º Rust æ˜¯ä¸€é—¨åŸºäºè¡¨è¾¾å¼ï¼ˆexpression-basedï¼‰çš„è¯­è¨€ï¼Œè¿™æ˜¯ä¸€ä¸ªéœ€è¦ç†è§£çš„ï¼ˆä¸åŒäºå…¶ä»–è¯­è¨€ï¼‰é‡è¦åŒºåˆ«ã€‚

è¯­å¥ä¸è¡¨è¾¾å¼çš„åŒºåˆ«:
- è¯­å¥(statements): æ˜¯æ‰§è¡Œä¸€äº›æ“ä½œä½†ä¸è¿”å›å€¼å¾—æŒ‡ä»¤
- è¡¨è¾¾å¼(expressions): è®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªå€¼

```rust
fn plus_two(arg: u32) -> u32 {
    let tmp = arg + 1; //ä»¥åˆ†å·ç»“å°¾çš„æ˜¯,è¯­å¥
    arg += 1 //è¡¨è¾¾å¼, æ³¨æ„æ²¡æœ‰åˆ†å·
    // åœ¨ Rust ä¸­ï¼Œå‡½æ•°çš„è¿”å›å€¼ç­‰åŒäºå‡½æ•°ä½“æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
    // ä½¿ç”¨ return ä¹Ÿå¯ä»¥
}

fn main() {
    let a = 9; //è¯­å¥

    let b = plus_two(a); //å‡½æ•°è°ƒç”¨æ˜¯è¡¨è¾¾å¼ , let b = xxx; æ•´ä½“åˆ™æ˜¯è¯­å¥
}
```


### ä»£ç æ³¨é‡Š

å•è¡Œæ³¨é‡Š, å¤šè¡Œæ³¨é‡Š, æ–‡æ¡£æ³¨é‡Š
```rust
// æ³¨é‡Š
/* æ³¨é‡Š */

/// è¿™æ˜¯ä¸€ä¸ªæ–‡æ¡£æ³¨é‡Š
fn foo() {
}
```

### æ§åˆ¶æµ

#### `if` è¡¨è¾¾å¼

```rust

fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else {
        println!("other");
    }


    // ç±»ä¼¼å…¶ä»–C++ä¸­çš„ä¸‰ç›®è¿ç®—ç¬¦
    let condition = true;
    let number = if condition {
        5  //ç±»å‹å¿…é¡»ç›¸åŒ
    } else {
        6  //ç±»å‹å¿…é¡»ç›¸åŒ
        // "str"  // error!!
    };


    // ä½¿ç”¨ if let 
    if let a = 9 {
        println!("a = {}", 9);
    }
}

```

#### å¾ªç¯è¯­å¥, loop, while, for

åªæœ‰`loop` å¾ªç¯å¯ä»¥ä½¿ç”¨ `break` ä»å¾ªç¯ä¸­è¿”å›å€¼

```rust

fn main() {

    //æ— é™å¾ªç¯
    /*
    loop {
        println!("ok......");
    }
    */

    // ä»å¾ªç¯è¿”å›(å¯ä»¥å¸¦ä¸Šè¿”å›å€¼), è¿™ä¸€ç‚¹ä¸å…¶ä»–è¯­è¨€ä¸é€š
    let mut n = 0;
    let result = loop {
        n += 1;
        if n == 10{
            break n * 2;  // å°† n * 2 ä½œä¸ºå¾ªç¯çš„è¿”å›å€¼
        }
    };
    println!("result = {}", result);



    /*
    let mut n = 0;
    let result = while true {
        n += 1;
        if n == 10{
            // can only break with a value inside `loop` or breakable block
            break n * 2;   // ç¼–è¯‘é”™è¯¯
        } 
    }
    println!("result = {}", result);
    */

    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result); 


    // for å¾ªç¯

    let mut sum = 0;
    for i in 0..100 {
        sum += i;
    }
    println!("sum = {}", sum);


    let a  = [1, 2, 3, 4, 5, 6];

    for it in a.iter() {
        //it æ˜¯(å¼•ç”¨)è¿­ä»£å™¨

        // println!("the value is {}", *it); //OK, æ‰‹åŠ¨è§£å¼•ç”¨
        println!("the value is {}", it); //ok, Rust ä¼šè‡ªåŠ¨è§£å¼•ç”¨
    }

}

```


## ç¬¬4ç«   æ‰€æœ‰æƒ

æ‰€æœ‰æƒè§„åˆ™

> - Each value in Rust has a variable thatâ€™s called its owner.
>- There can only be one owner at a time.
> - When the owner goes out of scope, the value will be dropped.

- 1.Rust ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªè¢«ç§°ä¸ºå…¶ æ‰€æœ‰è€…ï¼ˆownerï¼‰çš„å˜é‡ã€‚
- 2.å€¼æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…(åœ¨åŒä¸€æ—¶é—´)ã€‚
- 3.å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒã€‚

https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html


#### Rustå˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼(1): ç§»åŠ¨

Rustå€Ÿé‰´äº†C++11ä¸­çš„å³å€¼å¼•ç”¨, Rusté’å‡ºäºè“è€Œèƒœäºè“.

å›é¡¾ä¸€ä¸‹C++11ä¸­çš„å³å€¼å¼•ç”¨

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <utility>

int main() 
{
    // https://en.cppreference.com/w/cpp/utility/move

    std::string strtmp = "c++ string";
    std::string strnew(std::move(strtmp));
    std::cout << "strtmp:" << strtmp << std::endl; //ç©º
    std::cout << "strnew:" << strnew  << std::endl;

}
```

Rustä¸­çš„æ‰€æœ‰æƒçš„è½¬ç§»

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; //æ­¤å¤„å°† s1 çš„æ‰€æœ‰æƒ ç§»äº¤ç»™äº† s2,  s1ä¸å†æœ‰æ•ˆ
    // println!("s1: {}", s1); //ç¼–è¯‘æŠ¥é”™: value borrowed here after move
    println!("s2: {}", s2);
}
```

`s1` è¢«ç§»åŠ¨åˆ°äº† `s2` ä¹‹å, `s1` ä¸å†æœ‰æ•ˆ.  ä¹Ÿå°±ä¸å­˜åœ¨å¤šæ¬¡é‡Šæ”¾çš„é—®é¢˜

![](./img/trpl04-04.png)


####  Rustå˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼(2): å…‹éš†

å³æ·±æ‹·è´

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

![](img/trpl04-03.png)


#### Rustå˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼(3):  æ‹·è´æ ˆä¸Šçš„æ•°æ®
åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„ç±»å‹è¢«æ•´ä¸ªå­˜å‚¨åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥æ‹·è´å…¶å®é™…çš„å€¼æ˜¯å¿«é€Ÿçš„

ä»»ä½•ç®€å•æ ‡é‡å€¼çš„ç»„åˆå¯ä»¥æ˜¯ Copy çš„ï¼Œä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹æ˜¯ Copy çš„, å¦‚ä¸‹:

- æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ u32ã€‚
- å¸ƒå°”ç±»å‹ï¼Œboolï¼Œå®ƒçš„å€¼æ˜¯ true å’Œ falseã€‚
- æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ï¼Œæ¯”å¦‚ f64ã€‚
- å­—ç¬¦ç±»å‹ï¼Œcharã€‚
- å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½æ˜¯ Copy çš„æ—¶å€™ã€‚æ¯”å¦‚ï¼Œ(i32, i32) æ˜¯ Copy çš„ï¼Œä½† (i32, String) å°±ä¸æ˜¯ã€‚

```rust

fn main() {

    //æ•´å‹ æ•°ç»„æ˜¯Copyçš„
    let x = 5;
    let y = x; 
    println!("x = {}, y = {}", x, y);


    //ä»…åŒ…å«Copyçš„ç±»å‹æ ˆä¸Šæ•°ç»„æ˜¯ Copy çš„
    let a = [1, 2, 3]; // æ ˆä¸Šæ•°ç»„
    let b = a;
    println!("a = {:?}", a);
    println!("b = {:?}", b);

    // å †ä¸Šæ•°ç»„ä¸æ˜¯ Copyçš„
    let sa = vec![1, 2, 3]; //å †ä¸Šæ•°ç»„  Vec<i32> 
    let sb = sa; //moved
    // println!("sa = {:?}", sa);  //ERROR
    println!("sb = {:?}", sb);

    // åŒ…å«å †ä¸Šæ•°æ® æ ˆä¸Šæ•°ç»„ä¸æ˜¯ Copyçš„
    let ss = [vec![1,2,3], vec![4, 5, 6]];
    let ss2 = ss; // moved
    // println!("{:?}", ss);  //ERROR
    println!("{:?}", ss2);

    // å¸ƒå°”ç±»å‹  æ˜¯ Copyçš„
    let bl: bool = false;
    let cl = bl;
    println!("bl = {}, cl = {}", bl, cl); // OK

    //æµ®ç‚¹å‹ f32 å’Œ f64  æ˜¯Copyçš„
    let f: f32 = 0.234f32;
    let f2 = f;
    println!("f = {}, f2 = {}", f, f2); //OK

    //å­—ç¬¦å‹ char  æ˜¯ Copyçš„
    let ch = 'ä¸­';
    let ch2 = ch;
    println!("ch = {}, ch2 = {}", ch, ch2); //OK


    //ä»…åŒ…å« Copyç±»å‹çš„ å…ƒç»„
    let tp = (1, 2.4, 'å›½', true, "good", [1, 2, 3]);
    let tp2  = tp;
    println!("tp = {:?}", tp); // OK
    println!("tp2 = {:?}", tp2); //OK
}
```


#### æ‰€æœ‰æƒä¸å‡½æ•°

å˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼šå°†å€¼èµ‹ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ç§»åŠ¨å®ƒã€‚å½“æŒæœ‰å †ä¸­æ•°æ®å€¼çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå…¶å€¼å°†é€šè¿‡ drop è¢«æ¸…ç†æ‰ï¼Œé™¤éæ•°æ®è¢«ç§»åŠ¨ä¸ºå¦ä¸€ä¸ªå˜é‡æ‰€æœ‰

```rust
fn foo() -> String {
    let s = String::from("hello");
    s   //ç§»å‡º
}

fn back(s: String) -> String {
    println!("back() s = {}", s);
    s
}

fn oof(s: String) {   //è·å–æ‰€æœ‰æƒ
    println!("oof() s = {}", s);
}

fn main() {

    let s1 = foo();
    println!("s1 = {}", s1); //OK

    let s2 = back(s1); // s1å·²ç»è¢«moved, 

    oof(s2); //moved
    // æ­¤å¤„ s1å·²ç»æ— æ•ˆ

    // println!("s2 = {}", s2); //ERROR
}
```

### å¼•ç”¨ä¸å€Ÿç”¨

å¼•ç”¨(reference): ä¸è·å–å˜é‡çš„æ‰€æœ‰æƒ,ä»…è·å–å˜é‡çš„å€¼
- ä¸å¯å˜å¼•ç”¨, å¯å˜å˜é‡å’Œä¸å¯å˜é‡éƒ½å¯ä»¥æœ‰ä¸å¯å˜å¼•ç”¨
- å¯å˜å¼•ç”¨, åªæœ‰å¯å˜å˜é‡æ‰æœ‰å¯å˜å¼•ç”¨

å€Ÿç”¨(borrowing): ä»¥å¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°ç§°ä¸ºå€Ÿç”¨

å¼•ç”¨çš„è§„åˆ™

- åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
- å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„


```rust

fn foo(s: &String) {
    println!("foo() s = {}", s);
    // s.push_str("boy");  // ERROR ä¸å¯å˜å¼•ç”¨,ä¸å¯ä¿®æ”¹
}

fn oof(s: &mut String) {
    println!("oof() s = {}", s);
    s.push_str("boy"); //OK , å¯å˜å¼•ç”¨å¯ä»¥ä¿®æ”¹
}

fn main() {
    let mut s = String::from("hello");
    foo(&s); //å€Ÿç”¨

    println!("main() s = {}", s);

    oof(&mut s); //å¯å˜
}
```


### åˆ‡ç‰‡(Slice)ç±»å‹


```rust
let s = String::from("hello world");

let hello: &str = &s[0..5];  // &strç±»å‹
let world = &s[6..11]; //
```



![](./img/trpl04-06.png)


```rust
//å€¼æ¥å— &String, ä¸æ¥æ”¶ &str
fn first(s: &String) -> &str{
    &s[0..1]
}

//å¯ä»¥æ¥å— &String , ä¹Ÿå¯ä»¥æ¥å— &str
fn second(s: &str) -> &str {
    &s[0..1]
}

fn main() {
    let s = "hello world";
    let s1 = String::from("hello world");
    // println!("{}", first(&s)); //error
    println!("{}", first(&s1)); //OK

    println!("{}", second(&s)); //OK
    println!("{}", second(&s1)); //OK   &String ä¼šè‡ªåŠ¨è½¬ä¸º &str
    println!("{}", second(&s1[..])); //OK  å³ &s1[..]
}
```

å…¶ä»–ç±»å‹çš„slice

```rust
fn main() {
    let a = [1, 2, 3, 4];
    println!("{:?}", &a[..]); // OK
    println!("{:?}", &a[2..]); // OK

    let sa = vec![1, 2, 3, 4];
    println!("{:?}", &sa[..]); // OK
    println!("{:?}", &sa[2..]); // OK

    //å…ƒç»„ä¸æ”¯æŒåˆ‡ç‰‡
    // let tp = (1, 2, 3, 4);
    // println!("{:?}", &tp[..]); // ERROR 
    // println!("{:?}", &tp[2..]); // ERROR
}
```


## ç¬¬5ç«  ç»“æ„ä½“

ç»“æ„ä½“åˆ†ç±»:

- æ™®é€šç»“æ„ä½“: åŒ…å«æ•°æ®å­—æ®µçš„ 
- å…ƒç»„ç»“æ„ä½“: æ²¡æœ‰å­—æ®µåç§°, åªæœ‰å­—æ®µç±»å‹
- ç±»å•å…ƒç»“æ„ä½“: ä¸åŒ…å«æ•°æ®å­—æ®µçš„, ä»…ç”¨æ¥å®ç°æŸäº›trait


```rust

struct User {
    username: String,
    email: String,
}

/*
struct User {
    username: &str, //ç»“æ„ä½“ä¸­ä½¿ç”¨å¼•ç”¨, éœ€è¦è€ƒè™‘å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
    email: &str,
}
*/


struct Color(u8, u8, u8); //å…ƒç»„ç»“æ„ä½“
struct Point3D(f64, f64, f64);

struct CanFly; //æ²¡æœ‰æ•°æ®å­—æ®µ, ç±»å•å…ƒç»“æ„ä½“


fn build_user(email: String, username: String) -> User {
    // å˜é‡ä¸å­—æ®µåŒåæ—¶, åˆå§‹åŒ–å¯ä»¥ç®€å†™(éœ€è¦å†™å‡ºå­—æ®µåç§°)
    User{
        username,
        email,
    }
}

fn main() {

    // let usr = User {"yqq", "1234@gmail.com" }; //ERROR

    let usr = build_user(String::from("yqq"), 
            String::from("123@gmail.com"));

    let usr2 = User {
        //åªèƒ½ç”¨String, ä¸èƒ½ç”¨å­—ç¬¦ä¸²å­—é¢å€¼(&str), å› ä¸ºç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜
        username: String::from( "yqq" ), 
        email: String::from( "234@gmail.com" )
    };

    let black = Color(0, 0, 0);

    let p = Point3D(1.23, -234.12, 992.999);
}
```

ä¸ºç»“æ„ä½“å®ç°æ–¹æ³•

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    //å…³è”æ–¹æ³•, åœ¨C++ä¸­å«é™æ€æ–¹æ³•
    fn name() -> String {
        String::from("Rectangle")
    }
}

impl Rectangle {
    fn get_width(&self) -> u32 {
        self.width
    }
}

fn main() {
    let rect = Rectangle { 
        width: 100,
        height: 100,
    };

    println!("é¢ç§¯: {}", rect.area());
    println!("name: {}", Rectangle::name());
    println!("width:{}", rect.get_width());
}
```


## ç¬¬6ç«  æšä¸¾ä¸æ¨¡å¼åŒ¹é…

ä¸»è¦å†…å®¹:
- `enum`
- `Option`
- `match`


æšä¸¾ç±»å‹

```rust
enum Message {
    Quit,  //æ²¡æœ‰å…³è”æ•°æ®
    Move { x: i32, y: i32 },  //åŒ¿åç»“æ„ä½“
    Write(String), //åŒ…å«String
    ChangeColor(i32, i32, i32), //åŒ…å«3ä¸ªi32
}

// å¯ä»¥ä¸º æšä¸¾ç±»å‹å®ç° æ–¹æ³•
impl Message {
    fn call(&self) {
        println!("call()");
    }
}

fn main() {
    let m = Message::Write(String::from("good"));
    m.call();
}
```


`Option` ,  `match` ,   `if let`

Option: Rustä¸­ä½¿ç”¨ Option<T>å¯¹ç©ºå’Œéç©ºè¿›è¡Œå¤„ç†

match: ä½¿ç”¨matchå¯ä»¥è¿›è¡Œæ¨¡å¼åŒ¹é…, æ¨¡å¼å¯ç”±å­—é¢å€¼,å˜é‡,é€šé…ç¬¦å’Œå…¶ä»–å†…å®¹ç»„æˆ. match çš„åŒ¹é…å¿…é¡»æ˜¯ "ç©·å°½" çš„, å³å¿…é¡»åŒ¹é…æ‰€æœ‰å¯èƒ½æ€§.

if let: å¯ä»¥è¿›è¡Œç®€å•çš„æ¨¡å¼åŒ¹é…

```rust
enum Option<T> {
    Some(T),
    None,
}
```

```rust
fn some_func(x: i32) -> Option<i32> {
    if x < 0 {
        return None;
    }
    Some(x + 1)
}


fn main() {

    for i in -3..3 {
        //å¯¹å‡½æ•°è¿”å›å€¼è¿›è¡Œæ£€æŸ¥
        match some_func(i) {
            None => println!("minus"),
            Some(n) => println!("{}", n),
        };
    }

    let n = 8;
    match n {
        1 => println!("1"),
        2 => println!("2"),
        _ => println!(">=3"),  // _ åŒ¹é…æ‰€æœ‰çš„å€¼
    };

    let n = Some(3);
    if let Some(3) == n {
        println!("3");
    }

    if let Some(num) = some_func(55) {
        println!("some_func return: {}", num);
    }
}

```


## ç¬¬7ç«  åŒ…ç®¡ç†

- åŒ…ï¼ˆPackagesï¼‰ï¼š Cargo çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œå®ƒå…è®¸ä½ æ„å»ºã€æµ‹è¯•å’Œåˆ†äº« crateã€‚
- Crates ï¼šä¸€ä¸ªæ¨¡å—çš„æ ‘å½¢ç»“æ„ï¼Œå®ƒå½¢æˆäº†åº“æˆ–äºŒè¿›åˆ¶é¡¹ç›®ã€‚
- æ¨¡å—ï¼ˆModulesï¼‰å’Œ useï¼š å…è®¸ä½ æ§åˆ¶ä½œç”¨åŸŸå’Œè·¯å¾„çš„ç§æœ‰æ€§ã€‚
- è·¯å¾„ï¼ˆpathï¼‰ï¼šä¸€ä¸ªå‘½åä¾‹å¦‚ç»“æ„ä½“ã€å‡½æ•°æˆ–æ¨¡å—ç­‰é¡¹çš„æ–¹å¼


åŒ…çš„è§„åˆ™:
- ä¸€ä¸ªåŒ…è‡³å¤šåªèƒ½åŒ…å«ä¸€ä¸ªåº“crate(library crate)
- ä¸€ä¸ªåŒ…ä¸­å¯ä»¥åŒ…å«ä»»æ„å¤šä¸ªäºŒè¿›åˆ¶crate(binary crate)
- åŒ…ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªcrate, æ— è®ºæ˜¯åº“crateè¿˜æ˜¯äºŒè¿›åˆ¶crate


å¸¸ç”¨æ“ä½œ:
- cargo new demo  åˆ›å»ºäºŒè¿›åˆ¶crate
- cargo new libdemo --lib   åˆ›å»ºåº“crate
- å¦‚æœä¸€ä¸ªåŒ…åŒæ—¶å«æœ‰ `src/main.rs` å’Œ `src/lib.rs`, åˆ™å®ƒæœ‰ä¸¤ä¸ªcrate: ä¸€ä¸ªåº“crateå’Œä¸€ä¸ªäºŒè¿›åˆ¶crate, ä¸”crateçš„åå­—éƒ½ä¸åŒ…ç›¸åŒ
- å¯ä»¥å°†æ–‡ä»¶æ”¾åœ¨ `src/bin`ç›®å½•ä¸‹, è¿™æ ·, ä¸€ä¸ªåŒ…å°±å¯ä»¥æœ‰å¤šä¸ªäºŒè¿›åˆ¶crate: `src/bin`ç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶éƒ½ä¼šè¢«ç¼–è¯‘æˆä¸åŒäºŒè¿›åˆ¶crate


ä¸€ä¸ªlib crate å¤šä¸ª binary crate, çš„åŒ…ç»“æ„

```
canteen
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ bin
â”‚   â”‚   â”œâ”€â”€ demo2.rs
â”‚   â”‚   â””â”€â”€ demo.rs
â”‚   â””â”€â”€ lib.rs
â””â”€â”€ target

```

ä¸€ä¸ªlib crate  ä¸€ä¸ªbinary crate, çš„åŒ…ç»“æ„

```
canteen2
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ main.rs
â””â”€â”€ target

```

ç»“æ„ä½“æˆå‘˜é»˜è®¤æ˜¯ç§æœ‰çš„
æšä¸¾æˆå‘˜é»˜è®¤æ˜¯å…¬æœ‰çš„


```rust
use crate::front_of_house::hosting::add_to_waitlist; //å¼•å…¥ä½œç”¨åŸŸ

use std::io::Result as IoResult; //åˆ«å

pub use crate::front_of_house::hosting; // é‡æ–°å¯¼å‡º

use std::{cmp::Ordering, io};
use std::io::{self, Write};

use std::collections::*; //å°†æ‰€æœ‰çš„å…¬æœ‰å®šä¹‰å¼•å…¥ä½œç”¨åŸŸ

```


### å°†æ¨¡å—åˆ†å‰²è¿›ä¸åŒæ–‡ä»¶

```
canteen3
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ front_of_house
â”‚   â”‚   â””â”€â”€ hosting.rs
â”‚   â”œâ”€â”€ front_of_house.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ main.rs
â””â”€â”€ target
```



æ–‡ä»¶: `src/main.rs`
```rust
use canteen3::eat_at_restaurant;
fn main() {
    eat_at_restaurant();
    println!("this is demo");
}
```

æ–‡ä»¶: `src/lib.rs`
```rust
// mod å…³é”®å­—å£°æ˜äº†æ¨¡å—ï¼Œ
//Rust ä¼šåœ¨ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­æŸ¥æ‰¾æ¨¡å—çš„ä»£ç ã€‚
mod front_of_house;  

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

æ–‡ä»¶: `src/front_of_house.rs`
```rust
pub mod hosting;
```

æ–‡ä»¶: `src/front_of_house/hosting.rs`

```rust
pub fn add_to_waitlist() {
    println!("canteen3: add_to_waitlist... ");
}
```


## ç¬¬8ç«  å¸¸è§é›†åˆ

ä¸»è¦å†…å®¹:
- `Vec<T>` : å †ä¸Šæ•°ç»„
- `String`: å †ä¸Šå­—ç¬¦ä¸²
- `Hasmap<K, V>`: KVæ•°æ®ç»“æ„, åŒæ ·åœ¨å †ä¸Š


#### vector

```rust

enum  MyEnum{
    Int(i32),
    Float(f64),
    Txt(String),
}

fn main() {

    let v2: Vec<f64> = Vec::new();
    let mut v3 = vec![1, 3, 9]; //ä½¿ç”¨å®, ä¹Ÿæ˜¯ Vec<iew> ç±»å‹

    for it in &mut v3 {
        *it += 100;
    }

    for it in v3 {
        println!("{}", it);
    }

    let vct = vec! [
        MyEnum::Float(1.234),
        MyEnum::Int(12),
        MyEnum::Txt(String::from("good")),
    ];
}
```

#### String 

String çš„ç±»å‹æ˜¯ç”±æ ‡å‡†åº“æä¾›çš„ï¼Œè€Œæ²¡æœ‰å†™è¿›æ ¸å¿ƒè¯­è¨€éƒ¨åˆ†ï¼Œå®ƒæ˜¯å¯å¢é•¿çš„ã€å¯å˜çš„ã€æœ‰æ‰€æœ‰æƒçš„ã€UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ç±»å‹ã€‚

Rust çš„å­—ç¬¦ä¸²ä¸æ”¯æŒç´¢å¼•

åŸå› : 
1. String æ˜¯ä¸€ä¸ª Vec<u8> çš„å°è£…ã€‚ 
2. æ¯ä¸ª Unicode æ ‡é‡å€¼éœ€è¦ä¸¤ä¸ªå­—èŠ‚å­˜å‚¨.
3. ç´¢å¼•æ“ä½œé¢„æœŸæ€»æ˜¯éœ€è¦å¸¸æ•°æ—¶é—´ (O(1))ã€‚ä½†æ˜¯å¯¹äº String ä¸å¯èƒ½ä¿è¯è¿™æ ·çš„æ€§èƒ½ï¼Œå› ä¸º Rust å¿…é¡»ä»å¼€å¤´åˆ°ç´¢å¼•ä½ç½®éå†æ¥ç¡®å®šæœ‰å¤šå°‘æœ‰æ•ˆçš„å­—ç¬¦ã€‚


```rust 

#[derive(PartialOrd, Eq, Ord)]
#[stable(feature = "rust1", since = "1.0.0")]
pub struct String {
    vec: Vec<u8>,
}

```

Rustçš„æ ¸å¿ƒè¯­è¨€ä¸­å­—ç¬¦ä¸²æŒ‡çš„æ˜¯ `str` å’Œ å­—ç¬¦ä¸²sliceå³ `&str`

`String`æœ‰æ ‡å‡†åº“æä¾›

ä»¥ä¸Šå­—ç¬¦ä¸²ç±»å‹éƒ½æ˜¯UTF-8ç¼–ç 

```rust

// String å†…éƒ¨æ˜¯æœ‰  Vec<u8> è¿›è¡Œå°è£…

fn main() {

    let mut s1 = String::from("é‡åº†ç«é”…");
    s1.push('èµ'); //Rustçš„å­—ç¬¦æŒ‡çš„æ˜¯ Unicodeå­—ç¬¦, è€Œä¸å•æŒ‡æ˜¯ä¸€ä¸ªå­—èŠ‚ascii
    s1.push_str("éå¸¸å¥½åƒ!");

    s1 += "éº»è¾£ç«é”…!";  
    s1 = s1 + "å¤©ä¸‹ä¸€ç»!";

    s1 = format!("{}ä¸­å›½é›„èµ·!, {}", s1, "æ£’æ£’å„¿!");
    
    println!("{}", s1);

    // println!("ç¬¬ä¸€ä¸ªå­—ç¬¦: {}", &s1[0]);  // String ä¸æ”¯æŒç´¢å¼•æ“ä½œ

    let d = "éº»è¾£å°é¢!"; //å­—é¢å€¼æ”¯æŒç´¢å¼•æ“ä½œ
    // println!("{}", &d[0..1]); //ERROR, 1ä¸æ˜¯æœ‰æ•ˆè¾¹ç•Œ
    println!("{}", &d[0..3]); // éº»
    println!("length: {}", d.len()); //13 ä¸ªå­—èŠ‚: ä¸€ä¸ªæ±‰å­—å 3ä¸ªå­—èŠ‚ æ„Ÿå¹å·æ˜¯è‹±æ–‡å ä¸€ä¸ªå­—èŠ‚


    //è¿™ç§æ–¹å¼éå†å­—ç¬¦ä¸²æ˜¯å®‰å…¨çš„
    for ch in d.chars() {
        println!("{}", ch);
    }
}
```

#### Hashmap

å’ŒC++çš„`std::map`æœ‰ç‚¹åŒºåˆ«:
- HashMapä»¥hashè¡¨ä½œä¸ºæ•°æ®ç»“æ„, C++ä¸­çš„`std::map`ä½¿ç”¨çº¢é»‘æ ‘
- HashMapæ’å…¥å¦‚æœé”®å·²ç»å­˜åœ¨æ—¶æ–°å€¼æ›¿æ¢æ—§å€¼; C++ä¸­`std::map`åˆ™æ’å…¥å¤±è´¥

```rust

use std::collections::HashMap;

fn main() {

    let mut scores = HashMap::new();
    scores.insert("Alice", 10);
    scores.insert("Bob", 199);


    let names = vec!["Alice", "Bob", "Coris"];
    let ages = vec![11, 10, 14];


    let cls: HashMap<_, _> = names.iter().zip(ages.iter()).collect();
    //ä½¿ç”¨ zip æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªå…ƒç»„çš„ vectorï¼Œå…¶ä¸­ â€œBlueâ€ ä¸ 10 æ˜¯ä¸€å¯¹
    println!("{:?}", cls); //{"Alice": 11, "Coris": 14, "Bob": 10}



    // æ‰€æœ‰æƒ
    let name = String::from("name");
    let age = String::from("age");
    let mut tmp = HashMap::new();

    // pub fn insert(&mut self, k: K, v: V) -> Option<V>
    // ä» insert æ–¹æ³•çš„å‡½æ•°ç­¾åæ¥çœ‹, k, v æ˜¯move
    tmp.insert(name, age); //moved

    println!("{:?}", tmp);
    // println!("name={}, age={}", name, age);

    let s = String::from("name");
    let kv = tmp.get_key_value( &s );
    match kv {
        Some((k, v)) => {
            println!("key:{}, value:{}", k, v);
        },
        None => println!("not found"),
    }

    /*
    for (k,v) in tmp {  // è¿™ç§æ–¹å¼æ˜¯ç§»åŠ¨! forå¾ªç¯ä¹‹åtmpå°±æ— æ•ˆäº†
        println!("k:{:?}, v:{:?}", k, v);
    }
    */

    for (k,v) in &tmp { //è¿™ç§æ–¹å¼æ‰æ˜¯å€Ÿç”¨
        println!("k:{:?}, v:{:?}", k, v);
    }

    tmp.insert("name".to_string(), "messi".to_string());  //å¦‚æœé”®å·²ç»å­˜åœ¨, åˆ™æ–°å€¼æ›¿æ¢å°±å€¼

    // åªæœ‰é”®ä¸å­˜åœ¨æ—¶æ‰æ’å…¥
    tmp.entry("name".to_string()).or_insert("news".to_string());

    println!("{:?}", tmp);

    let text = "hello world wonderful world";
    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        // pub fn or_insert(self, default: V) -> &'a mut V
        // æ ¹æ® or_insert çš„å‡½æ•°ç­¾å
        // or_insertä¼šè¿”å›ä¸€ä¸ªå€¼å¾—å¯å˜å¼•ç”¨
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", map);

}
```

C++ä¸­ `std::map` æ’å…¥ç›¸åŒçš„keyçš„æƒ…å†µ:

```cpp
#include <iostream>
#include <map>
#include <string>

int main()
{
    std::map<std::string, int> mp;

    //insertæ–¹æ³•è¿”å›å€¼ç±»å‹: std::pair<std::map<std::string, int>::iterator, bool>
    auto ret = mp.insert(std::make_pair("name", 234));
    if(!ret.second){
        std::cout << "æ’å…¥å¤±è´¥" << std::endl;
    }else{
        std::cout << "æ’å…¥æˆåŠŸ" << std::endl;
        auto it = *ret.first;
        std::cout << it.first << " : " << it.second << std::endl;
    }

    ret = mp.insert(std::make_pair("name", 234));
    if(!ret.second){
        std::cout << "æ’å…¥å¤±è´¥" << std::endl;
    } else {
        auto it = *ret.first;
        std::cout << it.first << " : " << it.second << std::endl;
        std::cout << "æ’å…¥æˆåŠŸ" << std::endl;
    }
}
```
è¿è¡Œè¾“å‡º:
```
æ’å…¥æˆåŠŸ
name : 234
æ’å…¥å¤±è´¥
```



## ç¬¬9ç«  é”™è¯¯å¤„ç†

ä¸»è¦å†…å®¹:
- panic!
- `Result<T, E>`
- å¥å£®åœ°å¤„ç†é”™è¯¯



### Resultæšä¸¾å®šä¹‰

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```



å…³äºResultçš„å¤„ç†

```rust

fn read_string_from_file_v1(path: &String) -> Result<String, io::Error> {
    let f = File::open(path);
    let mut f = match f {
        Ok(file) => file, // è¿”å›æ–‡ä»¶å¥æŸ„
        Err(error) => return Err(error), //ç›´æ¥è¿”å›
    };

    let mut s = String::new();
    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}


fn read_string_from_file_v2(path: &String) -> Result<String, io::Error> {
    let mut s = String::new();
    File::open(path)?.read_to_string(&mut s)?;
    Ok(s)
}


fn read_string_from_file_v3(path: &String) -> Result<String, io::Error> {
    fs::read_to_string(path)
}



//main å‡½æ•°æ˜¯ç‰¹æ®Šçš„ï¼Œå…¶å¿…é¡»è¿”å›ä»€ä¹ˆç±»å‹æ˜¯æœ‰é™åˆ¶çš„ã€‚main å‡½æ•°çš„ä¸€ä¸ªæœ‰æ•ˆçš„è¿”å›å€¼æ˜¯ ()ï¼ŒåŒæ—¶å‡ºäºæ–¹ä¾¿ï¼Œå¦ä¸€ä¸ªæœ‰æ•ˆçš„è¿”å›å€¼æ˜¯ Result<T, E>
fn main() -> Result<(), Box<dyn error::Error>> {

    let path = String::from("tmp.txt");
    /*
    // v1
    let file_content = match read_string_from_file(&s) {
        Ok(content) => content,
        Err(error) => {
            println!("read file error: {}", error);
            return ;
        }
    };
    */

    /*
    // v2
    let file_content =  match read_string_from_file_v2(&path) {
        Ok(content) => content,
        Err(error) => {
            println!("read file error: {}", error);
            return ; 
        }
    };
    */

    // v3
    let file_content  =  read_string_from_file_v3(&path)?;
    println!("file content: {}", file_content);
    Ok(())
}
```




## ç¬¬10ç«  æ³›å‹, trait, ç”Ÿå‘½å‘¨æœŸ


### æ³›å‹

- åœ¨å‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹
- åœ¨ç»“æ„ä½“ä¸­ä½¿ç”¨æ³›å‹
- åœ¨æšä¸¾ä¸­ä½¿ç”¨æ³›å‹
- æ–¹æ³•ä¸­ä½¿ç”¨

```rust
use std::cmp::{PartialOrd, PartialEq} ;
// use std::mem::


// åœ¨å‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹
fn largest<T: PartialOrd>(v: &[T]) -> &T {
    let mut max = &v[0];
    for item in v.iter() {
        if item > &max {
            max  = item;
        }
    }
    max
}


//ç»“æ„ä½“ä¸­ä½¿ç”¨æ³›å‹
struct Point<X, Y> {
    x: X, 
    y: Y,
}

impl<X, Y> Point<X, Y> {
    // æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹
    fn mixup<XX, YY>(self, other: Point<XX, YY>) -> Point<X, YY> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}



fn main() {

    let v = vec![1, -1, 3, 9, 4];
    if let x =  largest(&v) {
        println!("x = {}", x);
    }

    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c'};

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}

```

æ³›å‹ä»£ç çš„æ€§èƒ½: 
Ruståœ¨ç¼–è¯‘æ—¶å¯¹æ³›å‹ä»£ç è¿›è¡Œ*å•æ€åŒ–*, å³ä¸ºä¸åŒçš„ç±»å‹ç”Ÿæˆç›¸åº”çš„ä»£ç ,  å¦‚C++ä¸­å¯¹æ³›å‹çš„ç¬¬ä¸€æ¬¡ç¼–è¯‘.



### trait


trait ä»¥ä¸€ç§æŠ½è±¡çš„æ–¹å¼å®šä¹‰å…±äº«çš„è¡Œä¸ºã€‚å¯ä»¥ä½¿ç”¨ trait bounds æŒ‡å®šæ³›å‹æ˜¯ä»»ä½•æ‹¥æœ‰ç‰¹å®šè¡Œä¸ºçš„ç±»å‹ã€‚

æ³¨æ„ï¼štrait ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„å¸¸è¢«ç§°ä¸º æ¥å£ï¼ˆinterfacesï¼‰çš„åŠŸèƒ½ï¼Œè™½ç„¶æœ‰ä¸€äº›ä¸åŒã€‚


å®ç° trait æ—¶éœ€è¦æ³¨æ„çš„ä¸€ä¸ªé™åˆ¶æ˜¯ï¼Œåªæœ‰å½“ trait æˆ–è€…è¦å®ç° trait çš„ç±»å‹ä½äº crate çš„æœ¬åœ°ä½œç”¨åŸŸæ—¶ï¼Œæ‰èƒ½ä¸ºè¯¥ç±»å‹å®ç° traitã€‚

ä½†æ˜¯ä¸èƒ½ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨ traitã€‚


è¿™ä¸ªé™åˆ¶æ˜¯è¢«ç§°ä¸º ç›¸å¹²æ€§ï¼ˆcoherenceï¼‰ çš„ç¨‹åºå±æ€§çš„ä¸€éƒ¨åˆ†ï¼Œæˆ–è€…æ›´å…·ä½“çš„è¯´æ˜¯ å­¤å„¿è§„åˆ™ï¼ˆorphan ruleï¼‰ï¼Œå…¶å¾—åäºä¸å­˜åœ¨çˆ¶ç±»å‹ã€‚è¿™æ¡è§„åˆ™ç¡®ä¿äº†å…¶ä»–äººç¼–å†™çš„ä»£ç ä¸ä¼šç ´åä½ ä»£ç ï¼Œåä¹‹äº¦ç„¶ã€‚



å› ä¸ºå‘ç¼–è¯‘å™¨æä¾›äº† trait bound ä¿¡æ¯, ç¼–è¯‘å™¨å°±å¯ä»¥æ£€æŸ¥å…·ä½“ç±»å‹çš„è¡Œä¸º, ç›¸æ¯”åŠ¨æ€è¯­è¨€åœ¨è¿è¡Œæ—¶å‡ºç°é”™è¯¯,Rustå°†è¿™äº›é”™è¯¯ç§»åˆ°äº†ç¼–è¯‘æ—¶, å¦å¤–, æ— éœ€åœ¨è¿è¡Œæ—¶æ£€æŸ¥æ–¹æ³•æ˜¯å¦å­˜åœ¨, å› ä¸ºç¼–è¯‘æ—¶å·²ç»æ£€æŸ¥è¿‡.



ä¸ªäººå¿ƒå¾—:
Rustè¯­è¨€éƒ¨åˆ†åŒ…å«äº†å¾ˆå¤šå’Œç¼–è¯‘å™¨æ‰“äº¤é“çš„å†…å®¹, ç›¸æ¯”å…¶ä»–è¯­è¨€æ¥è¯´ , Rustè¦æ±‚ç¨‹åºå‘˜éå¸¸æ¸…æ¥šè‡ªå·±æƒ³è¦ä»€ä¹ˆå’Œåœ¨åšä»€ä¹ˆ,å¹¶ä¸”æŠŠè¿™äº›å‘Šè¯‰ç¼–è¯‘å™¨,è®©ç¼–è¯‘å™¨ååŠ©æ£€æŸ¥,ä¿è¯æ­£ç¡®æ€§.



ä½¿ç”¨ trait bound å®ç° ä¸Šé¢çš„  `largest` å‡½æ•°, å’Œä¸Šé¢çš„ç‰ˆæœ¬å·®ä¸å¤š, å¢åŠ äº† Copy çš„trait bound , for å¾ªç¯ä¸­ä½¿ç”¨ `&item`å¼•ç”¨

```rust
use std::cmp::PartialOrd;
// use std::c


fn largest<T>(v: &[T] ) -> T  where T: PartialOrd + Copy {
    let mut max = v[0];
    for &item in v.iter() {
        if item > max {
            max = item;
        }
    }

    max
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

```


#### trait å¯¹è±¡

åæ–‡æœ‰traitçš„å†…å®¹: https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html


```rust
pub trait Mammal {
    fn eat(&self);
}

struct Human;
struct Dog;
struct God {
    pub lifes: Vec<Box<dyn Mammal>>,
}

impl God {

    // fn live_multi_v2(m: &[ Box<dyn Mammal> ]){
    pub fn live_multi_v2(&self){
        for item in self.lifes.iter() {
            item.eat();
        }
    }
}

impl Mammal for Human {
    fn eat(&self) {
        println!("human eat");
    }
}


impl Mammal for Dog {
    fn eat(&self) {
        println!("Dog eat");
    }
}

// fn live_multi<T>(m: &[T]) where T: Mammal { // error
// fn live_multi(m: &[Box<dyn Mammal>]) {  // &[std::boxed::Box<(dyn Mammal + 'static)>]
// fn live_multi(m: &[Box<dyn Mammal>]) {
fn live_multi(m: &Vec<Box<dyn Mammal>>) {
    for item in m.iter() {
        item.eat();
    }
}


fn main() {


    // let god = God{
    //     lifes:
    //     vec![ 
    //         Box::new(Human{}), 
    //         Box::new(Dog{}) ,
    //     ] 
    // };

    // god.live_multi_v2();

    //å¦‚æœä¸åŠ ç±»å‹æ³¨è§£, ç¼–è¯‘å™¨ä¼šå°†vçš„ç±»å‹æ¨å¯¼ä¸º: std::vec::Vec<std::boxed::Box<Human>>
    // let v = vec![ 
    //     Box::new(Human), 
    //     Box::new(Dog) ,
    // ]; 


    let v: std::vec::Vec<std::boxed::Box<(dyn Mammal)>>  = vec![ 
        Box::new(Human), 
        Box::new(Dog) ,
    ];

    live_multi(&v); //ok
    // live_multi(&v[..]); //ok

}

```





### ç”Ÿå‘½å‘¨æœŸ

ç”Ÿå‘½å‘¨æœŸ(lifetime)æ˜¯Rustæœ€ä¸ä¼—ä¸åŒçš„åŠŸèƒ½.


Rustç¼–è¯‘å™¨æœ‰ å€Ÿç”¨æ£€æŸ¥å™¨(borrow checker) , å®ƒä¼šæ¯”è¾ƒä½œç”¨åŸŸæ¥åˆ¤æ–­æ‰€æœ‰çš„å€Ÿç”¨æ˜¯å¦æœ‰æ•ˆ.

å¦‚æœè¢«å¼•ç”¨çš„å¯¹è±¡æ¯”å®ƒçš„å¼•ç”¨è€…å­˜åœ¨çš„æ—¶é—´æ›´çŸ­, é‚£ä¹ˆå¼•ç”¨æ— æ•ˆ.


```rust
fn longest(x : &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```


```rust

// é€šè¿‡åœ¨å‡½æ•°ç­¾åä¸­æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°æ—¶ï¼Œ
// æˆ‘ä»¬å¹¶æ²¡æœ‰æ”¹å˜ä»»ä½•ä¼ å…¥åè¿”å›çš„å€¼çš„ç”Ÿå‘½å‘¨æœŸã€‚
// è€Œæ˜¯æŒ‡å‡ºä»»ä½•ä¸éµå®ˆè¿™ä¸ªåè®®çš„ä¼ å…¥å€¼éƒ½å°†è¢«å€Ÿç”¨æ£€æŸ¥å™¨æ‹’ç»ã€‚

// æ³›å‹ç”Ÿå‘½å‘¨æœŸ 'a  çš„å…·ä½“ç”Ÿå‘½å‘¨æœŸ  ç­‰äº  x, y ä¸¤è€…ç”Ÿå‘½å‘¨æœŸè¾ƒå°è€…çš„ç”Ÿå‘½å‘¨æœŸ
// å› æ­¤
// å°±èƒ½ä¿è¯è¿”å›çš„å¼•ç”¨å€¼åœ¨ x å’Œ y ä¸­è¾ƒçŸ­çš„é‚£ä¸ªç”Ÿå‘½å‘¨æœŸç»“æŸä¹‹å‰ä¿æŒæœ‰æ•ˆã€‚
fn longest<'a>(x : &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

ç”Ÿå‘½å‘¨æœŸè¯­æ³•æ˜¯ç”¨äºå°†å‡½æ•°çš„å¤šä¸ªå‚æ•°ä¸å…¶è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œå…³è”çš„ã€‚ä¸€æ—¦ä»–ä»¬å½¢æˆäº†æŸç§å…³è”ï¼ŒRust å°±æœ‰äº†è¶³å¤Ÿçš„ä¿¡æ¯æ¥å…è®¸å†…å­˜å®‰å…¨çš„æ“ä½œå¹¶é˜»æ­¢ä¼šäº§ç”Ÿæ‚¬å‚æŒ‡é’ˆäº¦æˆ–æ˜¯è¿åå†…å­˜å®‰å…¨çš„è¡Œä¸ºã€‚







```rust




// å‡½æ•°æˆ–æ–¹æ³•çš„å¼•ç”¨å‚æ•°
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}


fn longest_v2<'a, 'b>(x: &'a str, y: &'a str)  -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}


// //the reference is valid for the lifetime `'c` as defined on the function body at 23:23
// //but the borrowed content is only valid for the lifetime `'b` as defined on the function body at 23:19
// fn longest_v3<'a, 'b, 'c>(x: &'a str, y: &'b str)  -> &'c str {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }



struct Coin<'a> {
    symbol: &'a str,
}


fn precious<'a>(x: &'a Coin, y: &'a Coin) -> &'a Coin<'a>{

    /*
    //OK
    if x.symbol.len() > y.symbol.len() {
        x
    } else {
        y
    }
    */


    /*
    // OK
    if x.symbol.len() > y.symbol.len() {
        return x;
    }
    return y;
    */

    if x.symbol.len() > y.symbol.len() {
        x;   // ^ expected `()`, found `&Coin<'_>`
        println!("x is {}", x.symbol);
        // return x;  //OK
    }
    y
}



/*

// OK

struct  Singer<'a> {
    name: &'a str,
    musics: &'a Box<Vec<String>>,
}

impl <'a>Singer<'a> {
    fn show(&'a self, music_name: &'a str) -> &'a str {
        for item in self.musics.iter() {
            if item == music_name {
                return item;
            }
        }
        &self.musics[0]
    }
}
*/



// OK
struct  Singer<'a, 'b> {
    name: &'a str,
    musics: &'b Box<Vec<String>>,  //å¦‚æœæ¢æˆ  Vec<str> åˆ™ç¼–è¯‘ä¸è¿‡, å› ä¸º stréœ€è¦ç¼–è¯‘æ—¶æœŸç¡®å®šå¤§å°?
}

impl <'a, 'b>Singer<'a, 'b> {
    fn show(&'a self, music_name: &'b str) -> &'a str {
        for item in self.musics.iter() {
            if item == music_name {
                return item;
            }
        }
        &self.musics[0]
    }
}

fn main() {

    let a = String::from("hello");
    let b = String::from("good");

    let r = longest(&a,  &b);
    println!("longest is : {}", r);


    let r = longest_v2(&a, &b);
    println!("longest is : {}", r);


    // let r = longest_v3(&a, &b);
    // println!("longest is : {}", r);

    // drop(a); //moved
    let cny = Coin {symbol: &a};
    let usd = Coin {symbol: "USD" };

    let p =  precious(&cny, &usd);
    println!("precious: {}", p.symbol);


    let bx  = Box::new(vec![
        "toooooo".to_string(),
        "shut".to_string(),
        "apple".to_string(),
        "he is ok".to_string(),
    ]);

    {
        let sg = Singer { name:"gous", musics: &bx};
        let name = "apple";
        let ret = sg.show( &name );
        println!("ret = {}", ret);
    }

    // println!("{:?}", bx);
    
}

```




### ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

åœ¨ä¸€äº›ç‰¹å®šçš„æƒ…å†µä¸‹ä¸éœ€è¦æŒ‡å®šç”Ÿå‘½å‘¨æœŸ:

The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: `fn foo<'a>(x: &'a i32);` a function with two parameters gets two separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so on.

The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32) -> &'a i32`.

The third rule is if there are multiple input lifetime parameters, but one of them is `&self` or `&mut self` because this is a method, the lifetime of self is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.


ç¬¬ä¸€æ¡è§„åˆ™æ˜¯æ¯ä¸€ä¸ªæ˜¯å¼•ç”¨çš„å‚æ•°éƒ½æœ‰å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚æ¢å¥è¯è¯´å°±æ˜¯ï¼Œæœ‰ä¸€ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼š`fn foo<'a>(x: &'a i32)`ï¼Œæœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°æœ‰ä¸¤ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œ`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`ï¼Œä¾æ­¤ç±»æ¨ã€‚

ç¬¬äºŒæ¡è§„åˆ™æ˜¯å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹äºˆç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼š`fn foo<'a>(x: &'a i32) -> &'a i32`ã€‚

ç¬¬ä¸‰æ¡è§„åˆ™æ˜¯å¦‚æœæ–¹æ³•æœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°å¹¶ä¸”å…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ &self æˆ– &mut selfï¼Œè¯´æ˜æ˜¯ä¸ªå¯¹è±¡çš„æ–¹æ³•(method)(è¯‘è€…æ³¨ï¼š è¿™é‡Œæ¶‰åŠrustçš„é¢å‘å¯¹è±¡å‚è§17ç« ), é‚£ä¹ˆ self çš„ç”Ÿå‘½å‘¨æœŸèµ‹äºˆç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚ç¬¬ä¸‰æ¡è§„åˆ™ä½¿å¾—æ–¹æ³•æ›´å®¹æ˜“è¯»å†™ï¼Œå› ä¸ºåªéœ€æ›´å°‘çš„ç¬¦å·ã€‚




```rust



//å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹äºˆç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
// fn show_append_suffix(x: &mut String) ->  &str {
fn show_append_suffix<'a>(x: &'a mut String) ->  &'a str {
    // x + "suffix"
    x.push_str("_suffix");
    &x[..]
}


struct Bottle<'a> {
    label: &'a str,
    cap: f64,
}

impl<'a > Bottle<'a > {
    //ç­‰æ•ˆ: fn get_label<'b>(&'a self, prefix: &'b str) -> &'a str {
    fn get_label(&self, prefix: &str) -> &str {
        println!("prefix:{}, {}:{}", prefix, self.label, self.cap);
        self.label
    }


    // å¦‚æœæ˜¯æ–¹æ³•, selfçš„ç”Ÿå‘½å‘¨æœŸå°†è¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‚æ•°
    // fn get_label_v2<'b>(&'a self, prefix: &'b str) -> &'a str {
    /*fn get_label_v2(&self, prefix: &str) -> &str { //ç­‰æ•ˆä¸Šé¢çš„å†™æ³•, ç¼–è¯‘ä¸è¿‡!
        println!("prefix:{}, {}:{}", prefix, self.label, self.cap);
        prefix
    }*/


    // fn get_label_v3<'b>(&'a self, prefix: &'b str) -> &'a str {
    /*fn get_label_v3(&self, prefix: &str) -> &str { //ç­‰æ•ˆäºä¸Šé¢çš„å†™æ³•, ç¼–è¯‘ä¸è¿‡!
        println!("prefix:{}, {}:{}", prefix, self.label, self.cap);
        if self.label.len() >  prefix.len() {
            self.label
        } else {
            prefix
        }
    }*/

    // å¿…é¡»åŠ ç”Ÿå‘½å‘¨æœŸæ³¨è§£, 'a æ˜¯ min('a, 'b),  å³ç”Ÿå‘½å‘¨æœŸæœ€çŸ­çš„é‚£ä¸ª
    // fn get_label_v4(&'a self, prefix: &'a str) -> &'a str {
    fn get_label_v4(&self, prefix: &'a str) -> &str {
        println!("prefix:{}, {}:{}", prefix, self.label, self.cap);
        if self.label.len() > prefix.len() {
            self.label 
        } else {
            prefix
        }
    }

    // fn get_longest(&self, x: &str, y: &str) -> &str {
    fn get_longest(&self, x: &'a str, y: &'a str) -> &str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
}


fn main() {
    let mut x = String::from("good");
    let rf = show_append_suffix(&mut x);

    // åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œåªèƒ½æ‹¥æœ‰"ä¸€ä¸ªå¯å˜å¼•ç”¨"æˆ–"ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨ä¹‹ä¸€"ï¼ˆè€Œä¸æ˜¯å…¨éƒ¨ï¼‰ã€‚
    // println!("x = {}", &x); 
    println!("rf= {}", &rf);


    let bt = Bottle {label: "hope", cap:0.2234};
    let label  = bt.get_label("good");
    println!("label: {}", label);


    let longer = bt.get_longest("short", "longest");
    println!("longer: {}", longer);

}


```








å…³äº  Option<T>

ä¸ºäº†æ‹¥æœ‰ä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å€¼ï¼Œä½ å¿…é¡»è¦æ˜¾å¼çš„å°†å…¶æ”¾å…¥å¯¹åº”ç±»å‹çš„ `Option<T>` ä¸­ã€‚æ¥ç€ï¼Œå½“ä½¿ç”¨è¿™ä¸ªå€¼æ—¶ï¼Œå¿…é¡»æ˜ç¡®çš„å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µã€‚åªè¦ä¸€ä¸ªå€¼ä¸æ˜¯ `Option<T>` ç±»å‹ï¼Œä½ å°± å¯ä»¥ å®‰å…¨çš„è®¤å®šå®ƒçš„å€¼ä¸ä¸ºç©ºã€‚



æ¨¡å—ç³»ç»Ÿï¼ˆthe module systemï¼‰åŒ…æ‹¬ï¼š

åŒ…ï¼ˆPackagesï¼‰ï¼š Cargo çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œå®ƒå…è®¸ä½ æ„å»ºã€æµ‹è¯•å’Œåˆ†äº« crateã€‚
Crates ï¼šä¸€ä¸ªæ¨¡å—çš„æ ‘å½¢ç»“æ„ï¼Œå®ƒå½¢æˆäº†åº“æˆ–äºŒè¿›åˆ¶é¡¹ç›®ã€‚
æ¨¡å—ï¼ˆModulesï¼‰å’Œ useï¼š å…è®¸ä½ æ§åˆ¶ä½œç”¨åŸŸå’Œè·¯å¾„çš„ç§æœ‰æ€§ã€‚
è·¯å¾„ï¼ˆpathï¼‰ï¼šä¸€ä¸ªå‘½åä¾‹å¦‚ç»“æ„ä½“ã€å‡½æ•°æˆ–æ¨¡å—ç­‰é¡¹çš„æ–¹å¼




ä¸€ä¸ªåŒ…ä¸­è‡³å¤š åªèƒ½ åŒ…å«ä¸€ä¸ªåº“ crate(library crate)ï¼›
åŒ…ä¸­å¯ä»¥åŒ…å«ä»»æ„å¤šä¸ªäºŒè¿›åˆ¶ crate(binary crate)ï¼›
åŒ…ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ª crateï¼Œæ— è®ºæ˜¯åº“çš„è¿˜æ˜¯äºŒè¿›åˆ¶çš„ã€‚


Cargo éµå¾ªçš„ä¸€ä¸ªçº¦å®šï¼šsrc/main.rs å°±æ˜¯ä¸€ä¸ªä¸åŒ…åŒåçš„äºŒè¿›åˆ¶ crate çš„ crate æ ¹ã€‚åŒæ ·çš„ï¼ŒCargo çŸ¥é“å¦‚æœåŒ…ç›®å½•ä¸­åŒ…å« src/lib.rsï¼Œåˆ™åŒ…å¸¦æœ‰ä¸å…¶åŒåçš„åº“ crateï¼Œä¸” src/lib.rs æ˜¯ crate æ ¹ã€‚crate æ ¹æ–‡ä»¶å°†ç”± Cargo ä¼ é€’ç»™ rustc æ¥å®é™…æ„å»ºåº“æˆ–è€…äºŒè¿›åˆ¶é¡¹ç›®ã€‚

å¦‚æœä¸€ä¸ªåŒ…åŒæ—¶å«æœ‰ src/main.rs å’Œ src/lib.rsï¼Œåˆ™å®ƒæœ‰ä¸¤ä¸ª crateï¼šä¸€ä¸ªåº“å’Œä¸€ä¸ªäºŒè¿›åˆ¶é¡¹ï¼Œä¸”åå­—éƒ½ä¸åŒ…ç›¸åŒã€‚é€šè¿‡å°†æ–‡ä»¶æ”¾åœ¨ src/bin ç›®å½•ä¸‹ï¼Œä¸€ä¸ªåŒ…å¯ä»¥æ‹¥æœ‰å¤šä¸ªäºŒè¿›åˆ¶ crateï¼šæ¯ä¸ª src/bin ä¸‹çš„æ–‡ä»¶éƒ½ä¼šè¢«ç¼–è¯‘æˆä¸€ä¸ªç‹¬ç«‹çš„äºŒè¿›åˆ¶ crate

Rust ä¸­é»˜è®¤æ‰€æœ‰é¡¹ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€ç»“æ„ä½“ã€æšä¸¾ã€æ¨¡å—å’Œå¸¸é‡ï¼‰éƒ½æ˜¯ç§æœ‰çš„ã€‚çˆ¶æ¨¡å—ä¸­çš„é¡¹ä¸èƒ½ä½¿ç”¨å­æ¨¡å—ä¸­çš„ç§æœ‰é¡¹ï¼Œä½†æ˜¯å­æ¨¡å—ä¸­çš„é¡¹å¯ä»¥ä½¿ç”¨ä»–ä»¬çˆ¶æ¨¡å—ä¸­çš„é¡¹ã€‚







UTF-8 ä¸­çš„ä¸­æ–‡å 3ä¸ªå­—èŠ‚, 

éå†å­—ç¬¦ä¸²å¯ä»¥ä½¿ç”¨ chars æ–¹æ³•


```rust

// å¦‚æœä½ éœ€è¦æ“ä½œå•ç‹¬çš„ Unicode æ ‡é‡å€¼ï¼Œæœ€å¥½çš„é€‰æ‹©æ˜¯ä½¿ç”¨ chars æ–¹æ³•ã€‚
// chars æ–¹æ³•ä¼šå°†å­—ç¬¦ä¸²åˆ†å¼€å¹¶è¿”å› char ç±»å‹çš„å€¼
for ch in "åŒ—äº¬çƒ¤é¸­!Beijing Duck!".chars() {
    println!("{}", ch);
}

```


Rust å°†é”™è¯¯ç»„åˆæˆä¸¤ä¸ªä¸»è¦ç±»åˆ«ï¼šå¯æ¢å¤é”™è¯¯ï¼ˆrecoverableï¼‰å’Œ ä¸å¯æ¢å¤é”™è¯¯ï¼ˆunrecoverableï¼‰ã€‚
- å¯æ¢å¤é”™è¯¯é€šå¸¸ä»£è¡¨å‘ç”¨æˆ·æŠ¥å‘Šé”™è¯¯å’Œé‡è¯•æ“ä½œæ˜¯åˆç†çš„æƒ…å†µï¼Œæ¯”å¦‚æœªæ‰¾åˆ°æ–‡ä»¶ã€‚
- ä¸å¯æ¢å¤é”™è¯¯é€šå¸¸æ˜¯ bug çš„åŒä¹‰è¯ï¼Œæ¯”å¦‚å°è¯•è®¿é—®è¶…è¿‡æ•°ç»„ç»“å°¾çš„ä½ç½®ã€‚


æˆ‘ä»¬å¯ä»¥è®¾ç½® RUST_BACKTRACE ç¯å¢ƒå˜é‡æ¥å¾—åˆ°ä¸€ä¸ª backtraceã€‚

```rust

enum Result<T, E> {
Ok(T),
Err(E),
}

```



åªè¦æ¯ä¸€ä¸ªé”™è¯¯ç±»å‹éƒ½å®ç°äº† from å‡½æ•°æ¥å®šä¹‰å¦‚å°†å…¶è½¬æ¢ä¸ºè¿”å›çš„é”™è¯¯ç±»å‹ï¼Œ? è¿ç®—ç¬¦ä¼šè‡ªåŠ¨å¤„ç†è¿™äº›è½¬æ¢ã€‚

?è¿ç®—ç¬¦: åªèƒ½ç”¨äºè¿”å› Result æˆ–è€…å…¶å®ƒå®ç°äº† std::ops::Try çš„ç±»å‹çš„å‡½æ•°


```rust


/*
match è¡¨è¾¾å¼ä¸é—®å·è¿ç®—ç¬¦æ‰€åšçš„æœ‰ä¸€ç‚¹ä¸åŒï¼š? è¿ç®—ç¬¦æ‰€ä½¿ç”¨çš„é”™è¯¯å€¼è¢«ä¼ é€’ç»™äº† from å‡½æ•°ï¼Œ
å®ƒå®šä¹‰äºæ ‡å‡†åº“çš„ From trait ä¸­ï¼Œå…¶ç”¨æ¥å°†é”™è¯¯ä»ä¸€ç§ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚
å½“ ? è¿ç®—ç¬¦è°ƒç”¨ from å‡½æ•°æ—¶ï¼Œæ”¶åˆ°çš„é”™è¯¯ç±»å‹è¢«è½¬æ¢ä¸ºå®šä¹‰ä¸ºå½“å‰å‡½æ•°è¿”å›çš„é”™è¯¯ç±»å‹ã€‚
è¿™åœ¨å½“ä¸€ä¸ªå‡½æ•°è¿”å›ä¸€ä¸ªé”™è¯¯ç±»å‹æ¥ä»£è¡¨æ‰€æœ‰å¯èƒ½å¤±è´¥çš„æ–¹å¼æ—¶å¾ˆæœ‰ç”¨ï¼Œ
å³ä½¿å…¶å¯èƒ½ä¼šå› å¾ˆå¤šç§åŸå› å¤±è´¥ã€‚åªè¦æ¯ä¸€ä¸ªé”™è¯¯ç±»å‹éƒ½å®ç°äº† from 
å‡½æ•°æ¥å®šä¹‰å¦‚å°†å…¶è½¬æ¢ä¸ºè¿”å›çš„é”™è¯¯ç±»å‹ï¼Œ? è¿ç®—ç¬¦ä¼šè‡ªåŠ¨å¤„ç†è¿™äº›è½¬æ¢ã€‚
*/
fn read_username_from_file_ex() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?; // ä½¿ç”¨ ? è¿ç®—ç¬¦è‡ªåŠ¨è½¬æ¢é”™è¯¯
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

```



panic! é€‚ç”¨åœºæ™¯:

- ç¤ºä¾‹ , ä»£ç åŸå‹, æµ‹è¯•ç”¨ä¾‹

- panic! é€šå¸¸é€‚åˆè°ƒç”¨ä¸èƒ½å¤Ÿæ§åˆ¶çš„å¤–éƒ¨ä»£ç æ—¶ï¼Œè¿™æ—¶æ— æ³•ä¿®å¤å…¶è¿”å›çš„æ— æ•ˆçŠ¶æ€ã€‚



æµ‹è¯•

- panic!
- should_panic! 
- assert!



é—­åŒ…

é—­åŒ…å®šä¹‰ä¼šä¸ºæ¯ä¸ªå‚æ•°å’Œè¿”å›å€¼æ¨æ–­ä¸€ä¸ªå…·ä½“ç±»å‹


```rust

et example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);

```


åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨æ˜¯ æƒ°æ€§çš„ï¼ˆlazyï¼‰


Iterator trait éœ€è¦å®ç° next æ–¹æ³•, å› ä¸ºä¸€äº›æ–¹æ³•ä¸­è°ƒç”¨äº† next æ–¹æ³•
è¿™äº›è°ƒç”¨ next æ–¹æ³•çš„æ–¹æ³•è¢«ç§°ä¸º æ¶ˆè´¹é€‚é…å™¨ï¼ˆconsuming adaptorsï¼‰


è¿­ä»£å™¨æ˜¯ Rust çš„ é›¶æˆæœ¬æŠ½è±¡ï¼ˆzero-cost abstractionsï¼‰ä¹‹ä¸€ï¼Œå®ƒæ„å‘³ç€æŠ½è±¡å¹¶ä¸ä¼šå¼•å…¥è¿è¡Œæ—¶å¼€é”€ï¼Œå®ƒä¸æœ¬è´¾å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹å¢æ™®ï¼ˆC++ çš„è®¾è®¡å’Œå®ç°è€…ï¼‰åœ¨ â€œFoundations of C++â€ï¼ˆ2012ï¼‰ ä¸­æ‰€å®šä¹‰çš„ é›¶å¼€é”€ï¼ˆzero-overheadï¼‰




Cargo å·¥ä½œç©ºé—´

å·¥ä½œç©ºé—´ æ˜¯ä¸€ç³»åˆ—å…±äº«åŒæ ·çš„ Cargo.lock å’Œè¾“å‡ºç›®å½•çš„åŒ…ã€‚
æˆ‘ä»¬çš„å·¥ä½œç©ºé—´æœ‰ä¸€ä¸ªäºŒè¿›åˆ¶é¡¹ç›®å’Œä¸¤ä¸ªåº“ã€‚äºŒè¿›åˆ¶é¡¹ç›®ä¼šæä¾›ä¸»è¦åŠŸèƒ½ï¼Œå¹¶ä¼šä¾èµ–å¦ä¸¤ä¸ªåº“ã€‚




æ™ºèƒ½æŒ‡é’ˆ


æ™ºèƒ½æŒ‡é’ˆåŒºåˆ«äºå¸¸è§„ç»“æ„ä½“çš„æ˜¾è‘—ç‰¹æ€§åœ¨äºå…¶å®ç°äº† Deref å’Œ Drop traitã€‚

Deref trait å…è®¸æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“å®ä¾‹è¡¨ç°çš„åƒå¼•ç”¨ä¸€æ ·ï¼Œè¿™æ ·å°±å¯ä»¥ç¼–å†™æ—¢ç”¨äºå¼•ç”¨ã€åˆç”¨äºæ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚

Drop trait å…è®¸æˆ‘ä»¬è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆç¦»å¼€ä½œç”¨åŸŸæ—¶è¿è¡Œçš„ä»£ç ã€‚


å¸¸ç”¨çš„æ™ºèƒ½æŒ‡é’ˆ

Box<T>ï¼Œç”¨äºåœ¨å †ä¸Šåˆ†é…å€¼
Rc<T>ï¼Œä¸€ä¸ªå¼•ç”¨è®¡æ•°ç±»å‹ï¼Œå…¶æ•°æ®å¯ä»¥æœ‰å¤šä¸ªæ‰€æœ‰è€…
Ref<T> å’Œ RefMut<T>ï¼Œé€šè¿‡ RefCell<T> è®¿é—®ï¼Œä¸€ä¸ªåœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œå€Ÿç”¨è§„åˆ™çš„ç±»å‹ã€‚



Box<T>  æ•°æ®å­˜æ”¾åœ¨å †ä¸Š ,  è€ŒæŒ‡å‘å †æ•°æ®çš„æŒ‡é’ˆåœ¨æ ˆä¸Š

- å½“æœ‰ä¸€ä¸ªåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„ç±»å‹ï¼Œè€Œåˆæƒ³è¦åœ¨éœ€è¦ç¡®åˆ‡å¤§å°çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨è¿™ä¸ªç±»å‹å€¼çš„æ—¶å€™
- å½“æœ‰å¤§é‡æ•°æ®å¹¶å¸Œæœ›åœ¨ç¡®ä¿æ•°æ®ä¸è¢«æ‹·è´çš„æƒ…å†µä¸‹è½¬ç§»æ‰€æœ‰æƒçš„æ—¶å€™
- å½“å¸Œæœ›æ‹¥æœ‰ä¸€ä¸ªå€¼å¹¶åªå…³å¿ƒå®ƒçš„ç±»å‹æ˜¯å¦å®ç°äº†ç‰¹å®š trait è€Œä¸æ˜¯å…¶å…·ä½“ç±»å‹çš„æ—¶å€™

    ç¬¬1ç§: é€’å½’ç±»å‹(å¦‚é€šè¿‡æŒ‡é’ˆå®ç°é“¾è¡¨)
    ç¬¬2ç§: å¤§æ•°æ®é‡æ‹·è´
    ç¬¬3ç§: trait å¯¹è±¡ 

    *y  åº•å±‚æ˜¯  *(y.deref())



æ³¨æ„ï¼Œæ¯æ¬¡å½“æˆ‘ä»¬åœ¨ä»£ç ä¸­ä½¿ç”¨ * æ—¶ï¼Œ * è¿ç®—ç¬¦éƒ½è¢«æ›¿æ¢æˆäº†å…ˆè°ƒç”¨ deref æ–¹æ³•å†æ¥ç€ä½¿ç”¨ * è§£å¼•ç”¨çš„æ“ä½œï¼Œä¸”åªä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œä¸ä¼šå¯¹ * æ“ä½œç¬¦æ— é™é€’å½’æ›¿æ¢ï¼Œè§£å¼•ç”¨å‡ºä¸Šé¢ i32 ç±»å‹çš„å€¼å°±åœæ­¢äº†


è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼ˆderef coercionsï¼‰æ˜¯ Rust åœ¨å‡½æ•°æˆ–æ–¹æ³•ä¼ å‚ä¸Šçš„ä¸€ç§ä¾¿åˆ©ã€‚å…¶å°†å®ç°äº† Deref çš„ç±»å‹çš„å¼•ç”¨è½¬æ¢ä¸ºåŸå§‹ç±»å‹é€šè¿‡ Deref æ‰€èƒ½å¤Ÿè½¬æ¢çš„ç±»å‹çš„å¼•ç”¨ã€‚å½“è¿™ç§ç‰¹å®šç±»å‹çš„å¼•ç”¨ä½œä¸ºå®å‚ä¼ é€’ç»™å’Œå½¢å‚ç±»å‹ä¸åŒçš„å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å°†è‡ªåŠ¨å‘ç”Ÿã€‚è¿™æ—¶ä¼šæœ‰ä¸€ç³»åˆ—çš„ deref æ–¹æ³•è¢«è°ƒç”¨ï¼ŒæŠŠæˆ‘ä»¬æä¾›çš„ç±»å‹è½¬æ¢æˆäº†å‚æ•°æ‰€éœ€çš„ç±»å‹ã€‚

è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€çš„åŠ å…¥ä½¿å¾— Rust ç¨‹åºå‘˜ç¼–å†™å‡½æ•°å’Œæ–¹æ³•è°ƒç”¨æ—¶æ— éœ€å¢åŠ è¿‡å¤šæ˜¾å¼ä½¿ç”¨ & å’Œ * çš„å¼•ç”¨å’Œè§£å¼•ç”¨ã€‚è¿™ä¸ªåŠŸèƒ½ä¹Ÿä½¿å¾—æˆ‘ä»¬å¯ä»¥ç¼–å†™æ›´å¤šåŒæ—¶ä½œç”¨äºå¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚

å½“æ‰€æ¶‰åŠåˆ°çš„ç±»å‹å®šä¹‰äº† Deref traitï¼ŒRust ä¼šåˆ†æè¿™äº›ç±»å‹å¹¶ä½¿ç”¨ä»»æ„å¤šæ¬¡ Deref::deref è°ƒç”¨ä»¥è·å¾—åŒ¹é…å‚æ•°çš„ç±»å‹ã€‚è¿™äº›è§£æéƒ½å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶ï¼Œæ‰€ä»¥åˆ©ç”¨è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å¹¶æ²¡æœ‰è¿è¡Œæ—¶æƒ©ç½šï¼


```rust


fn foo(name: &str) {
    println!("hello , {}", name);
}

let m = MyBox::new(String::from("rustman"));
foo(&m);
foo( &(*m)[..] )  // Rust æ²¡æœ‰è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€åˆ™å¿…é¡»ç¼–å†™çš„ä»£ç 

```


Rust åœ¨å‘ç°ç±»å‹å’Œ trait å®ç°æ»¡è¶³ä¸‰ç§æƒ…å†µæ—¶ä¼šè¿›è¡Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼š

å½“ `T: Deref<Target=U>` æ—¶ä» &T åˆ° &Uã€‚
å½“ `T: DerefMut<Target=U> `æ—¶ä» &mut T åˆ° &mut Uã€‚
å½“ `T: Deref<Target=U> `æ—¶ä» &mut T åˆ° &Uã€‚

std::mem::drop è¿›è¡Œæå‰æ¸…ç†
æˆ‘ä»¬ä¹Ÿæ— éœ€æ‹…å¿ƒæ„å¤–çš„æ¸…ç†æ‰ä»åœ¨ä½¿ç”¨çš„å€¼ï¼Œè¿™ä¼šé€ æˆç¼–è¯‘å™¨é”™è¯¯ï¼šæ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä¹Ÿä¼šç¡®ä¿ drop åªä¼šåœ¨å€¼ä¸å†è¢«ä½¿ç”¨æ—¶è¢«è°ƒç”¨ä¸€æ¬¡ã€‚


Rc<T> å¼•ç”¨æŠ€æœ¯æ™ºèƒ½æŒ‡é’ˆ
æ³¨æ„ Rc<T> åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ï¼›


å…‹éš† Rc<T> ä¼šå¢åŠ å¼•ç”¨è®¡æ•°
å½“ä¸€ä¸ªRcå˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶, å¼•ç”¨è®¡æ•°ä¼šè‡ªåŠ¨å‡1


é€šè¿‡ä¸å¯å˜å¼•ç”¨, Rc<T>å…è®¸å¤šä¸ªåœ°æ–¹åªè¯»åœ°å…±äº«æ•°æ®.
ä½†æ˜¯, ä¸å…è®¸å¤šä¸ªå¯å˜å¼•ç”¨!

å›é¡¾å€Ÿç”¨è§„åˆ™ä¹‹ä¸€: åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆ åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆ åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚



å†…éƒ¨å¯å˜æ€§ï¼ˆInterior mutabilityï¼‰æ˜¯ Rust ä¸­çš„ä¸€ä¸ªè®¾è®¡æ¨¡å¼ï¼Œå®ƒå…è®¸ä½ å³ä½¿åœ¨æœ‰ä¸å¯å˜å¼•ç”¨æ—¶ä¹Ÿå¯ä»¥æ”¹å˜æ•°æ®ï¼Œè¿™é€šå¸¸æ˜¯å€Ÿç”¨è§„åˆ™æ‰€ä¸å…è®¸çš„ã€‚ä¸ºäº†æ”¹å˜æ•°æ®ï¼Œè¯¥æ¨¡å¼åœ¨æ•°æ®ç»“æ„ä¸­ä½¿ç”¨ unsafe ä»£ç æ¥æ¨¡ç³Š Rust é€šå¸¸çš„å¯å˜æ€§å’Œå€Ÿç”¨è§„åˆ™ã€‚


å›é¡¾å€Ÿç”¨è§„åˆ™:
1.åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œåªèƒ½æ‹¥æœ‰"ä¸€ä¸ªå¯å˜å¼•ç”¨"æˆ–"ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨ä¹‹ä¸€"ï¼ˆè€Œä¸æ˜¯å…¨éƒ¨ï¼‰ã€‚
2.å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚


å¯¹äºå¼•ç”¨å’Œ Box<T>ï¼Œå€Ÿç”¨è§„åˆ™çš„ä¸å¯å˜æ€§ä½œç”¨äºç¼–è¯‘æ—¶ã€‚
å¯¹äº RefCell<T>ï¼Œè¿™äº›ä¸å¯å˜æ€§ä½œç”¨äº è¿è¡Œæ—¶ã€‚
å¯¹äºå¼•ç”¨å’ŒBox<T>ï¼Œå¦‚æœè¿åè¿™äº›è§„åˆ™ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚è€Œå¯¹äº RefCell<T>ï¼Œå¦‚æœè¿åè¿™äº›è§„åˆ™ç¨‹åºä¼š panic å¹¶é€€å‡ºã€‚


RefCell<T> æ­£æ˜¯ç”¨äºå½“ä½ ç¡®ä¿¡ä»£ç éµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œè€Œç¼–è¯‘å™¨ä¸èƒ½ç†è§£å’Œç¡®å®šçš„æ—¶å€™ã€‚

æ³¨æ„: Rc<T>ï¼ŒRefCell<T> åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ã€‚


é€‰æ‹© Box<T>ï¼ŒRc<T> æˆ– RefCell<T> çš„ç†ç”±ï¼š

- Rc<T> å…è®¸ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼›Box<T> å’Œ RefCell<T> æœ‰å•ä¸€æ‰€æœ‰è€…ã€‚

- Box<T> å…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨æ£€æŸ¥ï¼›Rc<T>ä»…å…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä¸å¯å˜å€Ÿç”¨æ£€æŸ¥ï¼›RefCell<T> å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨æ£€æŸ¥ã€‚

- å› ä¸º RefCell<T> å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œå¯å˜å€Ÿç”¨æ£€æŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å³ä¾¿ RefCell<T> è‡ªèº«æ˜¯ä¸å¯å˜çš„æƒ…å†µä¸‹ä¿®æ”¹å…¶å†…éƒ¨çš„å€¼ã€‚



RefCell<T> åœ¨è¿è¡Œæ—¶è®°å½•å€Ÿç”¨

RefCell<T> è®°å½•å½“å‰æœ‰å¤šå°‘ä¸ªæ´»åŠ¨çš„ Ref<T> å’Œ RefMut<T> æ™ºèƒ½æŒ‡é’ˆã€‚æ¯æ¬¡è°ƒç”¨ borrowï¼ŒRefCell<T> å°†æ´»åŠ¨çš„ä¸å¯å˜å€Ÿç”¨è®¡æ•°åŠ ä¸€ã€‚å½“ Ref å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¸å¯å˜å€Ÿç”¨è®¡æ•°å‡ä¸€ã€‚å°±åƒç¼–è¯‘æ—¶å€Ÿç”¨è§„åˆ™ä¸€æ ·ï¼ŒRefCell<T> åœ¨ä»»ä½•æ—¶å€™åªå…è®¸æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨æˆ–ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚


å¦‚æœæˆ‘ä»¬å°è¯•è¿åè¿™äº›è§„åˆ™ï¼Œç›¸æ¯”å¼•ç”¨æ—¶çš„ç¼–è¯‘æ—¶é”™è¯¯ï¼ŒRefCell<T> çš„å®ç°ä¼šåœ¨è¿è¡Œæ—¶ panic!

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
```




RefCell<T> çš„ä¸€ä¸ªå¸¸è§ç”¨æ³•æ˜¯ä¸ Rc<T> ç»“åˆã€‚å›å¿†ä¸€ä¸‹ Rc<T> å…è®¸å¯¹ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œä¸è¿‡åªèƒ½æä¾›æ•°æ®çš„ä¸å¯å˜è®¿é—®ã€‚å¦‚æœæœ‰ä¸€ä¸ªå‚¨å­˜äº† RefCell<T> çš„ Rc<T> çš„è¯ï¼Œå°±å¯ä»¥å¾—åˆ°æœ‰å¤šä¸ªæ‰€æœ‰è€… å¹¶ä¸” å¯ä»¥ä¿®æ”¹çš„å€¼äº†ï¼



Cell<T>ï¼Œå®ƒæœ‰äº›ç±»ä¼¼ RefCell<T>ï¼Œé™¤äº†æä¾›å†…éƒ¨å€¼çš„å¼•ç”¨ï¼Œå…¶å€¼è¿˜ä¼šè¢«æ‹·è´è¿›å’Œæ‹·è´å‡º Cell<T>



å¼•ç”¨å¾ªç¯ä¸å†…å­˜æ³„éœ²


åˆ›å»ºå¼•ç”¨å¾ªç¯å¹¶ä¸å®¹æ˜“ï¼Œä½†ä¹Ÿä¸æ˜¯ä¸å¯èƒ½ã€‚å¦‚æœä½ æœ‰åŒ…å« Rc<T> çš„ RefCell<T> å€¼æˆ–ç±»ä¼¼çš„åµŒå¥—ç»“åˆäº†å†…éƒ¨å¯å˜æ€§å’Œå¼•ç”¨è®¡æ•°çš„ç±»å‹ï¼Œè¯·åŠ¡å¿…å°å¿ƒç¡®ä¿ä½ æ²¡æœ‰å½¢æˆä¸€ä¸ªå¼•ç”¨å¾ªç¯ï¼›ä½ æ— æ³•æŒ‡æœ› Rust å¸®ä½ æ•è·å®ƒä»¬ã€‚åˆ›å»ºå¼•ç”¨å¾ªç¯æ˜¯ä¸€ä¸ªç¨‹åºä¸Šçš„é€»è¾‘ bugï¼Œä½ åº”è¯¥ä½¿ç”¨è‡ªåŠ¨åŒ–æµ‹è¯•ã€ä»£ç è¯„å®¡å’Œå…¶ä»–è½¯ä»¶å¼€å‘æœ€ä½³å®è·µæ¥ä½¿å…¶æœ€å°åŒ–ã€‚



å¾ªç¯å°†ç”±ä¸€äº›æ‹¥æœ‰æ‰€æœ‰æƒçš„å…³ç³»å’Œä¸€äº›æ— æ‰€æœ‰æƒçš„å…³ç³»ç»„æˆï¼Œåªæœ‰æ‰€æœ‰æƒå…³ç³»æ‰èƒ½å½±å“å€¼æ˜¯å¦å¯ä»¥è¢«ä¸¢å¼ƒ

Weak<T> æ²¡æœ‰æ‰€æœ‰æƒ,   
Weak<T> å¼•ç”¨çš„å€¼å¯èƒ½å·²ç»è¢«ä¸¢å¼ƒäº†, å¯ä»¥è°ƒç”¨ Weak<T> å®ä¾‹çš„ upgrade æ–¹æ³•
è¿™ä¼šè¿”å› Option<Rc<T>>
å¦‚æœ Rc<T> å€¼è¿˜æœªè¢«ä¸¢å¼ƒï¼Œåˆ™ç»“æœæ˜¯ Someï¼›å¦‚æœ Rc<T> å·²è¢«ä¸¢å¼ƒï¼Œåˆ™ç»“æœæ˜¯ Noneã€‚


ä»¥ä¸‹ä¾‹å­å¯¹äºç†è§£  Rc<T> å’Œ Weak<T> æœ‰å¾ˆå¤§å¸®åŠ©

```rust

use std::rc::{Rc, Weak};
use std::cell::RefCell;


#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}


fn main() {
    let  leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()), //æ­¤å¤„æ˜¯ç©ºWeakå¼•ç”¨
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade()); //upgradeè·å–ä¸åˆ°æ—¶, è¿”å›None
    println!("child: {:?}", leaf.children);

    println!("leaf strong = {}, weak = {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf)); // 1, 0


    {
        let branch =  Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),  //å°†children æŒ‡å‘  leaf
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch); //å°†leafçš„parentæŒ‡å‘ branch, 

        
        println!("branch strong = {}, weak = {}", Rc::strong_count(&branch), Rc::weak_count(&branch)); //1, 1

        println!("leaf strong = {}, weak = {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf)); //2, 0

    } // branchç¦»å¼€ä½œç”¨äº, å…¶childrenæŒ‡å‘leafçš„å¼ºå¼•ç”¨è‡ªåŠ¨å‡1,æ­¤æ—¶strong_countä¸º0,æ•…è€Œå°†branché‡Šæ”¾, 
      // leafä¸­parentæŒ‡å‘branchçš„å¼±å¼•ç”¨ä¹Ÿè‡ªåŠ¨å‡1, æ­¤æ—¶ä¸º0; å› branchå·²é‡Šæ”¾, æ‰€ä»¥leafçš„strong_countä¹Ÿå‡1


    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade()); // æ­¤æ—¶ upgrade è¿”å› branch
    // println!("child: {:?}",  branch.children);

    println!("leaf strong = {}, weak = {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf)); //1, 0

}

```


ç¬¬15ç« --æ™ºèƒ½æŒ‡é’ˆ, æ€»ç»“: 

- Box<T> æœ‰ä¸€ä¸ªå·²çŸ¥çš„å¤§å°å¹¶æŒ‡å‘åˆ†é…åœ¨å †ä¸Šçš„æ•°æ®
- Rc<T> è®°å½•äº†å †ä¸Šæ•°æ®çš„å¼•ç”¨æ•°é‡ä¸€éå¯ä»¥æ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…
- RefCell<T> å’Œå…¶ä»–å†…éƒ¨å¯å˜æ€§ æä¾›äº†ä¸€ä¸ªå¯ä»¥ç”¨äºå½“éœ€è¦ä¸å¯å˜ç±»å‹ä½†æ˜¯
   éœ€è¦æ”¹å˜å…¶å†…éƒ¨å€¼èƒ½åŠ›çš„ç±»å‹,å¹¶åœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™.

Deref trait å’Œ Drop trait

å¼•ç”¨å¾ªç¯é€ æˆå†…å­˜æ³„éœ²

ä½¿ç”¨ç”¨ Weak<T> é¿å…å¾ªç¯å¼•ç”¨




ç¬¬16ç«   æ— ç•å¹¶å‘

å¹¶å‘ç¼–ç¨‹(Concurrent programming) , ä»£è¡¨ç¨‹åºä¸åŒéƒ¨åˆ†ç›¸äº’ç‹¬ç«‹æ‰§è¡Œ
å¹¶è¡Œç¼–ç¨‹(Parrallel programming), ä»£è¡¨ç¨‹åºä¸åŒéƒ¨åˆ†åŒæ—¶æ‰§è¡Œ

æœ¬ç« å†…å®¹:

- å¦‚ä½•åˆ›å»ºçº¿ç¨‹æ¥åŒæ—¶è¿è¡Œå¤šæ®µä»£ç 
- æ¶ˆæ¯ä¼ é€’(Message passing) å¹¶å‘, å…¶ä¸­é€šé“(channel) è¢«ç”¨æ¥åœ¨çº¿ç¨‹é—´ä¼ é€’æ¶ˆæ¯.
- å…±äº«çŠ¶æ€(Shared state)å¹¶å‘, å…¶ä¸­å¤šä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®åŒä¸€ç‰‡æ•°æ®
- Sync å’Œ Send  trait, å°†Rustçš„å¹¶å‘ä¿è¯æ‰©å±•åˆ°ç”¨æˆ·å®šä¹‰çš„ä»¥åŠæ ‡å‡†åº“æä¾›çš„ç±»å‹ä¸­.




å¤šçº¿ç¨‹å¸¸è§é—®é¢˜:
- ç«äº‰çŠ¶æ€ï¼ˆRace conditionsï¼‰ï¼Œå¤šä¸ªçº¿ç¨‹ä»¥ä¸ä¸€è‡´çš„é¡ºåºè®¿é—®æ•°æ®æˆ–èµ„æº
- æ­»é”ï¼ˆDeadlocksï¼‰ï¼Œä¸¤ä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…å¯¹æ–¹åœæ­¢ä½¿ç”¨å…¶æ‰€æ‹¥æœ‰çš„èµ„æºï¼Œè¿™ä¼šé˜»æ­¢å®ƒä»¬ç»§ç»­è¿è¡Œ
- åªä¼šå‘ç”Ÿåœ¨ç‰¹å®šæƒ…å†µä¸”éš¾ä»¥ç¨³å®šé‡ç°å’Œä¿®å¤çš„ bug



thread::spawn() ç”¨äºåˆ›å»ºçº¿ç¨‹   ,  è¿”å› JoinHanle<T>

JoinHandle.join().unwrap()  ç”¨äºé˜»å¡ç­‰å¾…å­çº¿ç¨‹ç»“æŸ


```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} for the spawned thread!", i);
            thread::sleep(Duration::from_secs(1));
        }
    }); // thread::spawn çš„è¿”å›å€¼ç±»å‹æ˜¯ JoinHandleã€‚
        //JoinHandle æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼,å½“å¯¹å…¶è°ƒç”¨ join æ–¹æ³•æ—¶ï¼Œå®ƒä¼šç­‰å¾…å…¶çº¿ç¨‹ç»“æŸã€‚

    // handle.join().unwrap(); //é˜»å¡ç­‰å¾…å­çº¿ç¨‹ç»“æŸ

    for i in 1..5 {
        println!("hi number {} for main thread!", i);
        thread::sleep(Duration::from_secs(1));
    }

    handle.join().unwrap(); //é˜»å¡ç­‰å¾…å­çº¿ç¨‹ç»“æŸ
}

```


```rust

use std::thread;

fn main() {

    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || { //ä½¿ç”¨ move å…³é”®å­—å¼ºåˆ¶è·å–å®ƒä½¿ç”¨çš„å€¼çš„æ‰€æœ‰æƒ,  ç§»åŠ¨äº†æ‰€æœ‰æƒ
        println!("Here's a vector: {:?}", v);
    });

    // è¿åäº†å€Ÿç”¨è§„åˆ™,ç¼–è¯‘æŠ¥é”™! åœ¨ç¼–è¯‘æ—¶æœŸé¿å…äº†æ½œåœ¨bug
    // drop(v); //value used here after move

    handle.join().unwrap();

}
```



```cpp
#include <iostream>
#include <thread>
#include <memory>
#include <string.h>
#include <chrono>

int main() 
{
    // char *p = new char[100]{0};
    char *p = new char[100]{0};
    auto thrd = std::thread([&](){
        std::this_thread::sleep_for( std::chrono::seconds(3));
        strcpy(p, "hello world!");
    });

    delete[] p;
    p = nullptr;
    
    if(thrd.joinable())
    {
        std::cout << "waiting for thread finished." << std::endl;
        thrd.join();
    }
    std::cout << "start clean " << std::endl;

    // delete[] p;
    // p = nullptr;
    return 0;
}
```




Mutex ä½¿ç”¨

```rust

use std::sync::Mutex;

fn main() {

    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = std::thread::spawn(move || {
            //ç¼–è¯‘é”™è¯¯: value moved into closure here, in previous iteration of loop
            let mut num = counter.lock().unwrap(); 
            *num += 1;
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}

```


ä½¿ç”¨ å¤šçº¿ç¨‹å’Œå¤šæ‰€æœ‰æƒ

åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­, 

Rc<T> å¹¶ä¸èƒ½å®‰å…¨çš„åœ¨çº¿ç¨‹é—´å…±äº«ã€‚å½“ Rc<T> ç®¡ç†å¼•ç”¨è®¡æ•°æ—¶ï¼Œå®ƒå¿…é¡»åœ¨æ¯ä¸€ä¸ª clone è°ƒç”¨æ—¶å¢åŠ è®¡æ•°ï¼Œå¹¶åœ¨æ¯ä¸€ä¸ªå…‹éš†è¢«ä¸¢å¼ƒæ—¶å‡å°‘è®¡æ•°ã€‚Rc<T> å¹¶æ²¡æœ‰ä½¿ç”¨ä»»ä½•å¹¶å‘åŸè¯­ï¼Œæ¥ç¡®ä¿æ”¹å˜è®¡æ•°çš„æ“ä½œä¸ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ã€‚åœ¨è®¡æ•°å‡ºé”™æ—¶å¯èƒ½ä¼šå¯¼è‡´è¯¡å¼‚çš„ bugï¼Œæ¯”å¦‚å¯èƒ½ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼Œæˆ–åœ¨ä½¿ç”¨ç»“æŸä¹‹å‰å°±ä¸¢å¼ƒä¸€ä¸ªå€¼ã€‚æˆ‘ä»¬æ‰€éœ€è¦çš„æ˜¯ä¸€ä¸ªå®Œå…¨ç±»ä¼¼ Rc<T>ï¼Œåˆä»¥ä¸€ç§çº¿ç¨‹å®‰å…¨çš„æ–¹å¼æ”¹å˜å¼•ç”¨è®¡æ•°çš„ç±»å‹ã€‚


```rust


use std::sync::Mutex;
use std::rc::Rc;
use std::thread;

fn main() {

    let counter = Rc::new( Mutex::new(0) );  // åœ¨å‰é¢å­¦ä¹  Rc<T> çš„æ—¶å€™, Rc<T> åªèƒ½ç”¨äºå•çº¿ç¨‹
    let mut handles = vec![];

    for _ in 0..10 {
        let ctr = Rc::clone(&counter);        // æ”¹æˆ Rc<T> ä¹‹å ä¾ç„¶æ˜¯ç¼–è¯‘é”™è¯¯:
        let handle = thread::spawn(move || {  //`std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
            let mut num = ctr.lock().unwrap();   // the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::sync::Mutex<i32>>`
            *num += 1;
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}

```


åŸå­å¼•ç”¨è®¡æ•°  Arc<T>

çº¿ç¨‹å®‰å…¨æ˜¯ä»¥ç‰ºç‰²æ€§èƒ½ä¸ºä»£ä»·.


RefCell<T> / Rc<T>  ä¸  Mutex<T> / Arc<T> çš„ç›¸ä¼¼æ€§:

ä½ å¯èƒ½æ³¨æ„åˆ°äº†ï¼Œå› ä¸º counter æ˜¯ä¸å¯å˜çš„ï¼Œä¸è¿‡å¯ä»¥è·å–å…¶å†…éƒ¨å€¼çš„å¯å˜å¼•ç”¨ï¼›
è¿™æ„å‘³ç€ Mutex<T> æä¾›äº†å†…éƒ¨å¯å˜æ€§ï¼Œå°±åƒ Cell ç³»åˆ—ç±»å‹é‚£æ ·ã€‚æ­£å¦‚ç¬¬åäº”ç« ä¸­ä½¿ç”¨
 RefCell<T> å¯ä»¥æ”¹å˜ Rc<T> ä¸­çš„å†…å®¹é‚£æ ·ï¼ŒåŒæ ·çš„å¯ä»¥ä½¿ç”¨ Mutex<T> æ¥æ”¹å˜ Arc<T> ä¸­çš„å†…å®¹ã€‚



å¦ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ç»†èŠ‚æ˜¯ Rust ä¸èƒ½é¿å…ä½¿ç”¨ Mutex<T> çš„å…¨éƒ¨é€»è¾‘é”™è¯¯ã€‚
å›å¿†ä¸€ä¸‹ç¬¬åäº”ç« ä½¿ç”¨ Rc<T> å°±æœ‰é€ æˆå¼•ç”¨å¾ªç¯çš„é£é™©ï¼Œè¿™æ—¶ä¸¤ä¸ª Rc<T> å€¼ç›¸äº’å¼•ç”¨ï¼Œ
é€ æˆå†…å­˜æ³„éœ²ã€‚åŒç†ï¼ŒMutex<T> ä¹Ÿæœ‰é€ æˆ æ­»é”ï¼ˆdeadlockï¼‰ çš„é£é™©ã€‚è¿™å‘ç”Ÿäºå½“ä¸€ä¸ªæ“ä½œ
éœ€è¦é”ä½ä¸¤ä¸ªèµ„æºè€Œä¸¤ä¸ªçº¿ç¨‹å„æŒä¸€ä¸ªé”ï¼Œè¿™ä¼šé€ æˆå®ƒä»¬æ°¸è¿œç›¸äº’ç­‰å¾…ã€‚


ä¸¤ä¸ªå¹¶å‘æ¦‚å¿µæ˜¯å†…åµŒäºè¯­è¨€ä¸­çš„ï¼šstd::marker ä¸­çš„ Sync å’Œ Send trait


é€šè¿‡ Send å…è®¸åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ:

Send æ ‡è®° trait è¡¨æ˜ç±»å‹çš„æ‰€æœ‰æƒå¯ä»¥åœ¨çº¿ç¨‹é—´ä¼ é€’ã€‚å‡ ä¹æ‰€æœ‰çš„ Rust ç±»å‹éƒ½æ˜¯Send çš„ï¼Œ
ä¸è¿‡æœ‰ä¸€äº›ä¾‹å¤–ï¼ŒåŒ…æ‹¬ Rc<T>ï¼šè¿™æ˜¯ä¸èƒ½ Send çš„ï¼Œå› ä¸ºå¦‚æœå…‹éš†äº† Rc<T> çš„å€¼å¹¶å°è¯•å°†å…‹éš†çš„
æ‰€æœ‰æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™ä¸¤ä¸ªçº¿ç¨‹éƒ½å¯èƒ½åŒæ—¶æ›´æ–°å¼•ç”¨è®¡æ•°ã€‚ä¸ºæ­¤ï¼ŒRc<T> è¢«å®ç°ä¸ºç”¨äº
å•çº¿ç¨‹åœºæ™¯ï¼Œè¿™æ—¶ä¸éœ€è¦ä¸ºæ‹¥æœ‰çº¿ç¨‹å®‰å…¨çš„å¼•ç”¨è®¡æ•°è€Œä»˜å‡ºæ€§èƒ½ä»£ä»·



å½“å°è¯•åœ¨ç¤ºä¾‹ 16-14 ä¸­è¿™ä¹ˆåšçš„æ—¶å€™ï¼Œä¼šå¾—åˆ°é”™è¯¯ the trait Send is not implemented for Rc<Mutex<i32>>ã€‚
è€Œä½¿ç”¨æ ‡è®°ä¸º Send çš„ Arc<T> æ—¶ï¼Œå°±æ²¡æœ‰é—®é¢˜äº†ã€‚

åŸºæœ¬ç±»å‹éƒ½æ˜¯Sendçš„, é™¤äº†è£¸æŒ‡é’ˆ


é€šè¿‡ Sync å…è®¸å¤šçº¿ç¨‹è®¿é—®

å®ç°äº† Sync çš„ç±»å‹å¯ä»¥å®‰å…¨çš„åœ¨å¤šä¸ªçº¿ç¨‹ä¸­æ‹¥æœ‰å…¶å€¼çš„å¼•ç”¨
å¯¹äºä»»æ„ç±»å‹ Tï¼Œå¦‚æœ &Tï¼ˆT çš„å¼•ç”¨ï¼‰æ˜¯ Send çš„è¯ T å°±æ˜¯ Sync çš„




æ‰‹åŠ¨å®ç° Send å’Œ Sync æ˜¯ä¸å®‰å…¨çš„:
é€šå¸¸å¹¶ä¸éœ€è¦æ‰‹åŠ¨å®ç° Send å’Œ Sync traitï¼Œå› ä¸ºç”± Send å’Œ Sync çš„ç±»å‹ç»„æˆçš„ç±»å‹ï¼Œè‡ªåŠ¨å°±æ˜¯ Send å’Œ Sync çš„ã€‚å› ä¸ºä»–ä»¬æ˜¯æ ‡è®° traitï¼Œç”šè‡³éƒ½ä¸éœ€è¦å®ç°ä»»ä½•æ–¹æ³•ã€‚ä»–ä»¬åªæ˜¯ç”¨æ¥åŠ å¼ºå¹¶å‘ç›¸å…³çš„ä¸å¯å˜æ€§çš„ã€‚

æ‰‹åŠ¨å®ç°è¿™äº›æ ‡è®° trait æ¶‰åŠåˆ°ç¼–å†™ä¸å®‰å…¨çš„ Rust ä»£ç ï¼Œç¬¬åä¹ç« å°†ä¼šè®²è¿°å…·ä½“çš„æ–¹æ³•ï¼›å½“å‰é‡è¦çš„æ˜¯ï¼Œåœ¨åˆ›å»ºæ–°çš„ç”±ä¸æ˜¯ Send å’Œ Sync çš„éƒ¨åˆ†æ„æˆçš„å¹¶å‘ç±»å‹æ—¶éœ€è¦å¤šåŠ å°å¿ƒï¼Œä»¥ç¡®ä¿ç»´æŒå…¶å®‰å…¨ä¿è¯ã€‚



æ€»ç»“:

Rust æä¾›äº†ç”¨äºæ¶ˆæ¯ä¼ é€’çš„é€šé“ï¼Œå’Œåƒ Mutex<T> å’Œ Arc<T> è¿™æ ·å¯ä»¥å®‰å…¨çš„ç”¨äºå¹¶å‘ä¸Šä¸‹æ–‡çš„æ™ºèƒ½æŒ‡é’ˆã€‚ç±»å‹ç³»ç»Ÿå’Œå€Ÿç”¨æ£€æŸ¥å™¨ä¼šç¡®ä¿è¿™äº›åœºæ™¯ä¸­çš„ä»£ç ï¼Œä¸ä¼šå‡ºç°æ•°æ®ç«äº‰å’Œæ— æ•ˆçš„å¼•ç”¨ã€‚ä¸€æ—¦ä»£ç å¯ä»¥ç¼–è¯‘äº†ï¼Œæˆ‘ä»¬å°±å¯ä»¥åšä¿¡è¿™äº›ä»£ç å¯ä»¥æ­£ç¡®çš„è¿è¡Œäºå¤šçº¿ç¨‹ç¯å¢ƒï¼Œè€Œä¸ä¼šå‡ºç°å…¶ä»–è¯­è¨€ä¸­ç»å¸¸å‡ºç°çš„é‚£äº›éš¾ä»¥è¿½è¸ªçš„ bugã€‚å¹¶å‘ç¼–ç¨‹ä¸å†æ˜¯ä»€ä¹ˆå¯æ€•çš„æ¦‚å¿µï¼šæ— æ‰€ç•æƒ§åœ°å¹¶å‘å§ï¼




Rust ä¸­çš„é¢å‘å¯¹è±¡

å°è£…: Rustå¯ä»¥ä½¿ç”¨pubä¸å¦æ¥å°è£…å®ç°ç»†èŠ‚
ç»§æ‰¿: Rustä¸èƒ½ç›´æ¥ç»§æ‰¿
   OOPä¸­ä½¿ç”¨ç»§æ‰¿çš„ç›®çš„: 
      1.å¤ç”¨ä»£ç   -->  Rustå¯ä»¥ä½¿ç”¨é»˜è®¤çš„traitæ–¹æ³•å®ç°è¡Œä¸ºå…±äº«
      2.å¤šæ€  --> Rust åˆ™é€šè¿‡æ³›å‹æ¥å¯¹ä¸åŒçš„å¯èƒ½ç±»å‹è¿›è¡ŒæŠ½è±¡ï¼Œå¹¶é€šè¿‡ trait bounds å¯¹è¿™äº›ç±»å‹æ‰€å¿…é¡»æä¾›çš„å†…å®¹æ–½åŠ çº¦æŸ

è¿‘æ¥ç»§æ‰¿ä½œä¸ºä¸€ç§è¯­è¨€è®¾è®¡çš„è§£å†³æ–¹æ¡ˆåœ¨å¾ˆå¤šè¯­è¨€ä¸­å¤±å® äº†ï¼Œå› ä¸ºå…¶æ—¶å¸¸å¸¦æœ‰å…±äº«å¤šäºæ‰€éœ€çš„ä»£ç çš„é£é™©ã€‚å­ç±»ä¸åº”æ€»æ˜¯å…±äº«å…¶çˆ¶ç±»çš„æ‰€æœ‰ç‰¹å¾ï¼Œä½†æ˜¯ç»§æ‰¿å´å§‹ç»ˆå¦‚æ­¤ã€‚å¦‚æ­¤ä¼šä½¿ç¨‹åºè®¾è®¡æ›´ä¸ºä¸çµæ´»ï¼Œå¹¶å¼•å…¥æ— æ„ä¹‰çš„å­ç±»æ–¹æ³•è°ƒç”¨ï¼Œæˆ–ç”±äºæ–¹æ³•å®é™…å¹¶ä¸é€‚ç”¨äºå­ç±»è€Œé€ æˆé”™è¯¯çš„å¯èƒ½æ€§ã€‚æŸäº›è¯­è¨€è¿˜åªå…è®¸å­ç±»ç»§æ‰¿ä¸€ä¸ªçˆ¶ç±»ï¼Œè¿›ä¸€æ­¥é™åˆ¶äº†ç¨‹åºè®¾è®¡çš„çµæ´»æ€§ã€‚

å› ä¸ºè¿™äº›åŸå› ï¼ŒRust é€‰æ‹©äº†ä¸€ä¸ªä¸åŒçš„é€”å¾„ï¼Œä½¿ç”¨ trait å¯¹è±¡è€Œä¸æ˜¯ç»§æ‰¿ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹ Rust ä¸­çš„ trait å¯¹è±¡æ˜¯å¦‚ä½•å®ç°å¤šæ€çš„ã€‚



ä»¥ä¸‹ä¾‹å­å¯¹äºç†è§£ trait å¯¹è±¡ å¾ˆæœ‰ç”¨

```rust


pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,  // traitå¯¹è±¡:å®ƒæ˜¯ Box ä¸­ä»»ä½•å®ç°äº† Draw trait çš„ç±»å‹çš„æ›¿èº«
}

impl Screen {
    //è¿™ä¸å®šä¹‰ä½¿ç”¨äº†å¸¦æœ‰ trait bound çš„æ³›å‹ç±»å‹å‚æ•°çš„ç»“æ„ä½“ä¸åŒã€‚
    //æ³›å‹ç±»å‹å‚æ•°ä¸€æ¬¡åªèƒ½æ›¿ä»£ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œè€Œ trait å¯¹è±¡åˆ™å…è®¸åœ¨è¿è¡Œæ—¶æ›¿ä»£å¤šç§å…·ä½“ç±»å‹
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw(); //è°ƒç”¨ç»„ä»¶çš„drawæ–¹æ³•, å…¶ç»„ä»¶å¿…é¡»æ˜¯å®ç°äº† Draw trait çš„ traitå¯¹è±¡
        }
    }
}


/*
//ä½¿ç”¨ æ³›å‹ç±»å‹å‚æ•°ç»“æ„ä½“ trait bound
// è¿™é™åˆ¶äº† Screen å®ä¾‹å¿…é¡»æ‹¥æœ‰ä¸€ä¸ªå…¨æ˜¯ Button ç±»å‹æˆ–è€…å…¨æ˜¯ TextField ç±»å‹çš„ç»„ä»¶åˆ—è¡¨
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
*/

pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        println!("Button draw: {}, {}, {}", self.width, self.height, self.label);
    }
}


struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        println!("SelectBox draw:{}, {}, {:?}", self.width, self.height, self.options);
    }
}

fn main() {

    let screen = Screen {
        components: vec![
            Box::new(SelectBox{
                width: 89,
                height:90,
                options: vec![
                    String::from("ok"),
                    String::from("this"),
                    String::from("rust"),
                ]
            }),
            Box::new(  {
                width: 50,
                heightButton: 10,
                label: String::from("Ok Button"),
            }),
        ],
    };


    screen.run(); //è¿è¡Œ
}

```

å½“ç¼–å†™åº“çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸çŸ¥é“ä½•äººä¼šåœ¨ä½•æ—¶å¢åŠ  SelectBox ç±»å‹ï¼Œä¸è¿‡ Screen çš„å®ç°èƒ½å¤Ÿæ“ä½œå¹¶ç»˜åˆ¶è¿™ä¸ªæ–°ç±»å‹ï¼Œå› ä¸º SelectBox å®ç°äº† Draw traitï¼Œè¿™æ„å‘³ç€å®ƒå®ç°äº† draw æ–¹æ³•ã€‚
è¿™ä¸ªæ¦‚å¿µ â€”â€” åªå…³å¿ƒå€¼æ‰€åæ˜ çš„ä¿¡æ¯è€Œä¸æ˜¯å…¶å…·ä½“ç±»å‹ â€”â€” ç±»ä¼¼äºåŠ¨æ€ç±»å‹è¯­è¨€ä¸­ç§°ä¸º é¸­å­ç±»å‹ï¼ˆduck typingï¼‰çš„æ¦‚å¿µï¼šå¦‚æœå®ƒèµ°èµ·æ¥åƒä¸€åªé¸­å­ï¼Œå«èµ·æ¥åƒä¸€åªé¸­å­ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€åªé¸­å­ï¼

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­, Screenä¸Šçš„runå®ç°ä¸­, runå¹¶ä¸éœ€è¦çŸ¥é“å„ä¸ªç»„ä»¶çš„å…·ä½“ç±»å‹æ˜¯ä»€ä¹ˆ, å®ƒå¹¶ä¸æ£€æŸ¥ç»„ä»¶æ˜¯ Button æˆ–è€… SelectBox çš„å®ä¾‹ã€‚
é€šè¿‡æŒ‡å®š Box<dyn Draw> ä½œä¸º components vector ä¸­å€¼çš„ç±»å‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç¡®å®šæ‰€æœ‰ç»„ä»¶éƒ½å®ç°äº† drawæ–¹æ³•ä»¥ä¾›åœ¨Screençš„runæ–¹æ³•è¢«è°ƒç”¨.

ä½¿ç”¨ trait å¯¹è±¡å’Œ Rust ç±»å‹ç³»ç»Ÿæ¥è¿›è¡Œç±»ä¼¼é¸­å­ç±»å‹æ“ä½œçš„ä¼˜åŠ¿æ˜¯æ— éœ€åœ¨è¿è¡Œæ—¶æ£€æŸ¥ä¸€ä¸ªå€¼æ˜¯å¦å®ç°äº†ç‰¹å®šæ–¹æ³•æˆ–è€…æ‹…å¿ƒåœ¨è°ƒç”¨æ—¶å› ä¸ºå€¼æ²¡æœ‰å®ç°æ–¹æ³•è€Œäº§ç”Ÿé”™è¯¯ã€‚
å¦‚æœå€¼æ²¡æœ‰å®ç° trait å¯¹è±¡æ‰€éœ€çš„ trait åˆ™ Rust ä¸ä¼šç¼–è¯‘è¿™äº›ä»£ç ã€‚



åŠ¨æ€åˆ†å‘(dynamic dispatch): ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æœŸæ— æ³•çŸ¥é“è°ƒç”¨äº†ä»€ä¹ˆæ–¹æ³•, åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šè°ƒç”¨äº†ä»€ä¹ˆæ–¹æ³•çš„ä»£ç .
é™æ€åˆ†å‘(static dispatch): ä¾‹å¦‚æ³›å‹çš„å•æ€åŒ–. ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æœŸä¸ºæ¯ä¸€ä¸ªè¢«æ³›å‹ç±»å‹å‚æ•°ä»£æ›¿çš„å…·ä½“ç±»å‹ç”Ÿæˆäº†éæ³›å‹çš„å‡½æ•°å’Œæ–¹æ³•å®ç°. 

traitå¯¹è±¡æ‰§è¡ŒåŠ¨æ€åˆ†å‘



Traitå¯¹è±¡è¦æ±‚å¯¹è±¡å®‰å…¨:

å¯¹è±¡å®‰å…¨ï¼ˆobject safeï¼‰çš„ trait æ‰å¯ä»¥ç»„æˆ trait å¯¹è±¡

å¦‚æœä¸€ä¸ª trait ä¸­æ‰€æœ‰çš„**æ–¹æ³•**æœ‰å¦‚ä¸‹å±æ€§æ—¶, åˆ™traitå°±æ˜¯å¯¹è±¡å®‰å…¨:
1. è¿”å›å€¼ç±»å‹ä¸ä¸º Self
2. æ–¹æ³•æ²¡æœ‰ä»»ä½•æ³›å‹ç±»å‹å‚æ•°

Self å…³é”®å­—æ˜¯æˆ‘ä»¬è¦å®ç° trait æˆ–æ–¹æ³•çš„ç±»å‹çš„åˆ«åã€‚å¯¹è±¡å®‰å…¨å¯¹äº trait å¯¹è±¡æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºä¸€æ—¦æœ‰äº† trait å¯¹è±¡ï¼Œå°±ä¸å†çŸ¥æ™“å®ç°è¯¥ trait çš„å…·ä½“ç±»å‹æ˜¯ä»€ä¹ˆäº†ã€‚å¦‚æœ trait æ–¹æ³•è¿”å›å…·ä½“çš„ Self ç±»å‹ï¼Œä½†æ˜¯å› ä¸º trait å¯¹è±¡ä¸çŸ¥é“å…¶çœŸæ­£çš„ç±»å‹ï¼Œé‚£ä¹ˆtraitæ–¹æ³•ä¸å¯èƒ½*æ¨å¯¼*å‡ºå…¶å…·ä½“ç±»å‹ã€‚
åŒç†å¯¹äºæ³›å‹ç±»å‹å‚æ•°æ¥è¯´ï¼Œå½“ä½¿ç”¨ trait æ—¶å…¶ä¼šæ”¾å…¥å…·ä½“çš„ç±»å‹å‚æ•°ï¼šæ­¤å…·ä½“ç±»å‹å˜æˆäº†å®ç°è¯¥ trait çš„ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚å½“ä½¿ç”¨ trait å¯¹è±¡æ—¶å…¶å…·ä½“ç±»å‹è¢«æŠ¹å»äº†ï¼Œæ•…æ— ä»å¾—çŸ¥æ”¾å…¥æ³›å‹å‚æ•°ç±»å‹çš„ç±»å‹æ˜¯ä»€ä¹ˆ.  (è¿™æ®µè¯å¾ˆéš¾ç†è§£, è¯·çœ‹ä¸‹é¢çš„ä¾‹å­)

ä¾‹å¦‚:
ä¸€ä¸ª trait çš„æ–¹æ³•ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„ä¾‹å­æ˜¯æ ‡å‡†åº“ä¸­çš„ Clone trait
```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```

String å®ç°äº† Clone traitï¼Œå½“åœ¨ String å®ä¾‹ä¸Šè°ƒç”¨ clone æ–¹æ³•æ—¶ä¼šå¾—åˆ°ä¸€ä¸ª String å®ä¾‹ã€‚ç±»ä¼¼çš„ï¼Œå½“è°ƒç”¨ Vec<T> å®ä¾‹çš„ clone æ–¹æ³•ä¼šå¾—åˆ°ä¸€ä¸ª Vec<T> å®ä¾‹ã€‚clone çš„ç­¾åéœ€è¦çŸ¥é“ä»€ä¹ˆç±»å‹ä¼šä»£æ›¿ Selfï¼Œå› ä¸ºè¿™æ˜¯å®ƒçš„è¿”å›å€¼, è€Œ traitå¯¹è±¡ä¸çŸ¥é“ã€‚




Rustå®ç°é¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼--çŠ¶æ€æ¨¡å¼

GoFå…³äºçŠ¶æ€æ¨¡å¼çš„å®šä¹‰: å…è®¸ä¸€ä¸ªå¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜å®ƒçš„è¡Œä¸º. å¯¹è±¡çœ‹èµ·æ¥ä¼¼ä¹ä¿®æ”¹äº†å®ƒçš„ç±». 

```rust

//  Rust å®ç° çŠ¶æ€æ¨¡å¼   (State Pattern)


pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn content(&self) -> &str {
        // ""

        // as_ref() è¿”å›  Option<&Box<State>>
        // å¦‚æœä¸è°ƒç”¨ as_refï¼Œå°†ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸ºä¸èƒ½å°† state ç§»åŠ¨å‡ºå€Ÿç”¨çš„ &self å‡½æ•°å‚æ•°ã€‚
        self.state.as_ref().unwrap().content(self)
    }

    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state  = Some(s.request_review());
        }
    }

    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve());
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State> ;

    // å¦‚æœå‚æ•°æœ‰å¼•ç”¨, å°±è¦æ³¨æ„ç”Ÿå‘½å‘¨æœŸçš„å£°æ˜
    fn content<'a>(&self, _post: &'a Post) -> &'a str {
        ""
    }
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }


    fn approve(self: Box<Self>) -> Box<dyn State> {
        // Box::new(Published {})
        self
    }

}


struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}


struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}


fn main() {

    // Draft --request_review()--> PendingReview --approve()--> Published


    let mut post = Post::new();

    post.add_text("I have a apple.");
    post.approve(); //å¯¹ Draft è°ƒç”¨ approve æ²¡æœ‰ä»»ä½•å†…å®¹
    post.request_review();
    println!("content: {}", post.content());

    post.request_review();
    println!("content: {}", post.content());


    post.approve();
    println!("content: {}", post.content());
}



```



ä»¥ä¸ŠRusté¢å‘å¯¹è±¡æ–¹å¼å®ç°çš„çŠ¶æ€æ¨¡å¼çš„ç¼ºç‚¹:

- å®ç°äº†çŠ¶æ€ä¹‹é—´çš„è½¬æ¢, çŠ¶æ€ä¹‹é—´æœ‰ä¾èµ–å…³ç³», å¦‚æœåœ¨ä¸¤ä¸ªçŠ¶æ€ä¹‹é—´æ–°å¢ä¸€ä¸ªçŠ¶æ€, å°±è¦ä¿®æ”¹ä»£ç .
- å¦ä¸€ä¸ªç¼ºç‚¹æ˜¯æˆ‘ä»¬ä¼šå‘ç°ä¸€äº›é‡å¤çš„é€»è¾‘ã€‚ä¸ºäº†æ¶ˆé™¤ä»–ä»¬ï¼Œå¯ä»¥å°è¯•ä¸º State trait ä¸­è¿”å› self çš„ request_review å’Œ approve æ–¹æ³•å¢åŠ é»˜è®¤å®ç°ï¼Œä¸è¿‡è¿™ä¼šè¿åå¯¹è±¡å®‰å…¨æ€§ï¼Œå› ä¸º trait ä¸çŸ¥é“ self å…·ä½“æ˜¯ä»€ä¹ˆã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå°† State ä½œä¸ºä¸€ä¸ª trait å¯¹è±¡ï¼Œæ‰€ä»¥éœ€è¦å…¶æ–¹æ³•æ˜¯å¯¹è±¡å®‰å…¨çš„ã€‚
å¦ä¸€ä¸ªé‡å¤æ˜¯ Post ä¸­ request_review å’Œ approve è¿™ä¸¤ä¸ªç±»ä¼¼çš„å®ç°ã€‚


å®Œå…¨æŒ‰ç…§é¢å‘å¯¹è±¡è¯­è¨€çš„å®šä¹‰å®ç°è¿™ä¸ªæ¨¡å¼å¹¶æ²¡æœ‰å°½å¯èƒ½åœ°åˆ©ç”¨ Rust çš„ä¼˜åŠ¿


Rust éé¢å‘å¯¹è±¡æ–¹å¼å®ç°çŠ¶æ€æ¨¡å¼

```rust

pub struct Post {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

pub struct DraftPost {
    content: String,
}


impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }

}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}

fn main() {

    let mut post = Post::new();
    post.add_text("I have some apples");

    let post = post.request_review();

    let post = post.approve();

    println!("content: {}", post.content());

}
```

åœ¨ Rust ä¸­é¢å‘å¯¹è±¡æ¨¡å¼å¹¶ä¸æ€»æ˜¯æœ€å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œå› ä¸º Rust æ‹¥æœ‰åƒæ‰€æœ‰æƒè¿™æ ·çš„é¢å‘å¯¹è±¡è¯­è¨€æ‰€æ²¡æœ‰çš„åŠŸèƒ½ã€‚



æ€»ç»“:
é˜…è¯»æœ¬ç« åï¼Œä¸ç®¡ä½ æ˜¯å¦è®¤ä¸º Rust æ˜¯ä¸€ä¸ªé¢å‘å¯¹è±¡è¯­è¨€ï¼Œç°åœ¨ä½ éƒ½è§è¯†äº† trait å¯¹è±¡æ˜¯ä¸€ä¸ª Rust ä¸­è·å–éƒ¨åˆ†é¢å‘å¯¹è±¡åŠŸèƒ½çš„æ–¹æ³•ã€‚åŠ¨æ€åˆ†å‘å¯ä»¥é€šè¿‡ç‰ºç‰²å°‘é‡è¿è¡Œæ—¶æ€§èƒ½æ¥ä¸ºä½ çš„ä»£ç æä¾›ä¸€äº›çµæ´»æ€§ã€‚è¿™äº›çµæ´»æ€§å¯ä»¥ç”¨æ¥å®ç°æœ‰åŠ©äºä»£ç å¯ç»´æŠ¤æ€§çš„é¢å‘å¯¹è±¡æ¨¡å¼ã€‚Rust ä¹Ÿæœ‰åƒæ‰€æœ‰æƒè¿™æ ·ä¸åŒäºé¢å‘å¯¹è±¡è¯­è¨€çš„åŠŸèƒ½ã€‚é¢å‘å¯¹è±¡æ¨¡å¼å¹¶ä¸æ€»æ˜¯åˆ©ç”¨ Rust ä¼˜åŠ¿çš„æœ€å¥½æ–¹å¼ï¼Œä½†ä¹Ÿæ˜¯å¯ç”¨çš„é€‰é¡¹ã€‚





ç¬¬18ç«    æ¨¡å¼

match åˆ†æ”¯
match è¡¨è¾¾å¼å¿…é¡»æ˜¯ ç©·å°½ï¼ˆexhaustiveï¼‰çš„ï¼Œæ„ä¸º match è¡¨è¾¾å¼æ‰€æœ‰å¯èƒ½çš„å€¼éƒ½å¿…é¡»è¢«è€ƒè™‘åˆ°ã€‚

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```



if let æ¡ä»¶è¡¨è¾¾å¼

while let æ¡ä»¶å¾ªç¯


```rust


fn main() {


    let mut statck = Vec::new();

    statck.push(1);
    statck.push(2);
    statck.push(3);
    statck.push(4);

    // while å¾ªç¯åªè¦ pop è¿”å› Some å°±ä¼šä¸€ç›´è¿è¡Œå…¶å—ä¸­çš„ä»£ç ã€‚ä¸€æ—¦å…¶è¿”å› Noneï¼Œwhile å¾ªç¯åœæ­¢ã€‚
    while let Some(n) = statck.pop() {
        println!("number: {}", n);
    }

}

```


while let çš„æ³¨æ„ç‚¹!

```rust

fn new(id: i32,  arc_receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
    let thread = thread::spawn(move || {

        /*
        loop {
            // ä½¿ç”¨ loop å¹¶åœ¨å¾ªç¯å—ä¹‹å†…è€Œä¸æ˜¯ä¹‹å¤–è·å–é”å’Œä»»åŠ¡ï¼Œ
            // lock æ–¹æ³•è¿”å›çš„ MutexGuard åœ¨ let job è¯­å¥ç»“æŸä¹‹åç«‹åˆ»å°±è¢«ä¸¢å¼ƒäº†
            let job = arc_receiver.lock().unwrap().recv().unwrap();
            println!("worker {} got a job, executing...", id);

            job();
        }
        */


        // å› ä¸º while è¡¨è¾¾å¼ä¸­çš„å€¼åœ¨æ•´ä¸ªå—ä¸€ç›´å¤„äºä½œç”¨åŸŸä¸­ï¼Œ
        // job() è°ƒç”¨çš„è¿‡ç¨‹ä¸­å…¶ä»ç„¶æŒæœ‰é”ï¼Œ
        // è¿™æ„å‘³ç€å…¶ä»– worker ä¸èƒ½æ¥æ”¶ä»»åŠ¡ã€‚

        //è¿™æ ·åšä¹Ÿæ˜¯åˆç†çš„, åè¿‡æ¥æ€è€ƒä¸€ä¸‹: å¦‚æœä¸æŒæœ‰MutexGuard, é‚£ä¹ˆ whileå¾ªç¯ä¸­çš„ä»£ç å°†è¢«åˆ«çš„çº¿ç¨‹å¹²æ‰°
        while let Ok(job) = arc_receiver.lock().unwrap().recv() {
            println!("worker {} got a job, executing...", id);

            job(); 
        }

    });

    Worker{
        id,
        thread,
    }
}

```



for å¾ªç¯


let è¯­å¥

```rust
let PATTERN = EXPRESSION;
```

```rust

let (x, y, z) = (1, 2, 3);  //ok

let (x, y) = (1, 2, 3);  // error 

```


å‡½æ•°å‚æ•°



æ¨¡å¼æœ‰ä¸¤ç§å½¢å¼ï¼š
refutableï¼ˆå¯åé©³çš„ï¼‰: å¯¹æŸäº›å¯èƒ½çš„å€¼è¿›è¡ŒåŒ¹é…ä¼šå¤±è´¥çš„æ¨¡å¼è¢«ç§°ä¸ºæ˜¯ å¯åé©³çš„ï¼ˆrefutableï¼‰
irrefutableï¼ˆä¸å¯åé©³çš„ï¼‰: èƒ½åŒ¹é…ä»»ä½•ä¼ é€’çš„å¯èƒ½å€¼çš„æ¨¡å¼è¢«ç§°ä¸ºæ˜¯ ä¸å¯åé©³çš„ï¼ˆirrefutableï¼‰

ä¾‹å¦‚: 
let x = 5; è¯­å¥ä¸­çš„ xï¼Œå› ä¸º x å¯ä»¥åŒ¹é…ä»»ä½•å€¼æ‰€ä»¥ä¸å¯èƒ½ä¼šå¤±è´¥, æ‰€ä»¥æ˜¯ä¸å¯åé©³çš„;
if let Some(x) = a_value è¡¨è¾¾å¼ä¸­çš„ Some(x)ï¼›å¦‚æœå˜é‡ a_value ä¸­çš„å€¼æ˜¯ None è€Œä¸æ˜¯ Someï¼Œé‚£ä¹ˆ Some(x) æ¨¡å¼ä¸èƒ½åŒ¹é…,  æ‰€ä»¥æ˜¯å¯åé©³çš„.


å‘½åå˜é‡æ˜¯åŒ¹é…ä»»ä½•å€¼çš„ä¸å¯åé©³æ¨¡å¼ï¼Œç„¶è€Œå½“å…¶ç”¨äº match è¡¨è¾¾å¼æ—¶æƒ…å†µä¼šæœ‰äº›å¤æ‚ã€‚å› ä¸º match ä¼šå¼€å§‹ä¸€ä¸ªæ–°ä½œç”¨åŸŸï¼Œmatch è¡¨è¾¾å¼ä¸­ä½œä¸ºæ¨¡å¼çš„ä¸€éƒ¨åˆ†å£°æ˜çš„å˜é‡ä¼šè¦†ç›– match ç»“æ„ä¹‹å¤–çš„åŒåå˜é‡ï¼Œä¸æ‰€æœ‰å˜é‡ä¸€æ ·ã€‚

å°è¯•ç‰›åˆ€:  ä»¥ä¸‹ä»£ç è¿è¡Œä¼šæ‰“å°å‡ºä»€ä¹ˆ?

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}

```

å¤šä¸ªæ¨¡å¼

```rust
let x  = 1;
match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}

```


é€šè¿‡ ..= åŒ¹é…å€¼å¾—èŒƒå›´

èŒƒå›´åªå…è®¸ç”¨äºæ•°å­—æˆ– char å€¼

```rust
{
    let x = 9;
    match x {
        1..=5 => println!("one through five"),
        // 6..10 => println!("six to 10"),
        _ => println!("something else"),
    }
}



{
    let x = '5';

    match x {
        'a' ..='j' => println!("a..j"),
        'k' ..='z' => println!("k..z"),
        _ => println!("something else"),
    }
}
```



è§£æ„ç»“æ„ä½“

```rust
// è§£æ„æšä¸¾
{
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32,i32),
    }


    // let msg = Message::ChangeColor(0xff, 0xff, 0xff); //black
    // let msg = Message::Move{x:99, y:0};
    // let msg = Message::Write(String::from("this is string"));
    let msg = Message::Quit{};

    match msg {
        Message::Quit => {
            println!("quit msg");
        }
        Message::Move{x, y} => {
            println!("move to {}, {}", x, y);
        }
        Message::Write(text) => println!("text msg: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("change color to {},{},{}", r, g, b);
        }
    }
}

```

ä½¿ç”¨  _ å¿½ç•¥ç‰¹å®šçš„å€¼
æ³¨æ„, åªä½¿ç”¨ _ å’Œä½¿ç”¨ä»¥ä¸‹åˆ’çº¿å¼€å¤´çš„åç§°æœ‰äº›å¾®å¦™çš„ä¸åŒï¼šæ¯”å¦‚ _x ä»ä¼šå°†å€¼ç»‘å®šåˆ°å˜é‡ï¼Œè€Œ _ åˆ™å®Œå…¨ä¸ä¼šç»‘å®šã€‚

```rust

    // å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼

    {
        fn foo(_: i32, y: i32) { // å¿½ç•¥ ç¬¬ä¸€ä¸ªå‚æ•°
            println!("foo() y = {}", y);
        }

        foo(3, 4);
    }


    {
        // let mut setting_value = Some(5);
        let mut setting_value = None;
        let new_setting_value = Some(10);
        // let new_setting_value = None;

        match (setting_value, new_setting_value) {
            (Some(_), Some(_)) => {
                println!("Can't overwrite and existing customized value")
            },
            _ => {
                setting_value = new_setting_value;
            }
        }
        println!("setting is {:?}", setting_value);
    }


    // å¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å¼ä¸­çš„å¤šå¤„ä½¿ç”¨ä¸‹åˆ’çº¿æ¥å¿½ç•¥ç‰¹å®šå€¼
    {

        let numbers  = (2, 4, 8, 16, 32);

        match numbers {
            (first, _, third, _, fifth)  => {
                println!("some numbmer: {}, {}, {}", first, third, fifth);
            },
        }

    }

    // é€šè¿‡åœ¨å˜é‡åå­—å‰åŠ ä¸€ä¸ªä¸‹åˆ’çº¿ä½œä¸ºå¼€å¤´, æ¥å¿½ç•¥æœªä½¿ç”¨å˜é‡
    {
        let _x = 99;
        let y = 999;
    }


    {
        
        let s = Some(String::from("Hello!"));

        if let Some(_) = s {
            println!("found a string");
        }

        println!("{:?}", s);
    }

```


ç”¨ .. å¿½ç•¥å‰©ä½™å€¼

```rust
// ç”¨ .. å¿½ç•¥å‰©ä½™å€¼
    {
        struct Point {
            x: i32,
            y: i32,
            z: i32,
        }

        let orgin  = Point{ x: 1, y: 0, z: 0 };
        
        match orgin {
            Point{x, .. } => println!("x is {}", x),
        }



        let numbers = (1, 2, 3, 4);

        match numbers {
            (first, .., last) => {
                println!("Some numbers: {}, {}", first, last);
            }
        }

    }
```


åŒ¹é…å®ˆå«(match guard)


```rust
// åŒ¹é…å®ˆå«  (match guard)
    {
        let num = Some(4);

        match num {
            Some(x) if x < 5 => println!("less than five: {}", x),
            Some(x) => println!("{}", x),
            None => (),
        }


        let x = Some(5);
        let y = 10;

        match x {
            Some(50) => println!("Got 50"),
            Some(n) if n == y => println!("Matched, n = {}", n),
            _ => println!("Default case, x = {:?}", x),
        }

        println!("at the end: x = {:?}, y = {}", x, y);
        
    }

    {
        let x = 4;
        let y = false;

        match x {
            4 | 5 | 6 if y => println!("yes"),  // x ä¸º 4, 5 æˆ– 6     å¹¶ä¸”  y ä¸ºtrue
            _ => println!("no"),
        }
    }

```


@ ç»‘å®šå˜é‡
at è¿ç®—ç¬¦ï¼ˆ@ï¼‰å…è®¸æˆ‘ä»¬åœ¨åˆ›å»ºä¸€ä¸ªå­˜æ”¾å€¼çš„å˜é‡çš„åŒæ—¶æµ‹è¯•å…¶å€¼æ˜¯å¦åŒ¹é…æ¨¡å¼ã€‚

```rust
 // @ ç»‘å®š
{
    enum Message {
        Hello {id: i32 },
    }
    
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {id: id_var @ 3..=7 } => {
            // æµ‹è¯• Message::Hello çš„ id å­—æ®µæ˜¯å¦ä½äº 3...7 èŒƒå›´å†…ï¼Œ
            // åŒæ—¶ä¹Ÿå¸Œæœ›èƒ½å°†å…¶å€¼ç»‘å®šåˆ° id_variable å˜é‡ä¸­ä»¥ä¾¿æ­¤åˆ†æ”¯ç›¸å…³è”çš„ä»£ç å¯ä»¥ä½¿ç”¨å®ƒã€‚
            println!("=====1========= {}", id_var);
        },
        Message::Hello { id: 10..=12 } => {
            // id å­—æ®µçš„å€¼å¯ä»¥æ˜¯ 10ã€11 æˆ– 12ï¼Œä¸è¿‡è¿™ä¸ªæ¨¡å¼çš„ä»£ç å¹¶ä¸çŸ¥æƒ…
            //ä¹Ÿä¸èƒ½ä½¿ç”¨ id å­—æ®µä¸­çš„å€¼ï¼Œå› ä¸ºæ²¡æœ‰å°† id å€¼ä¿å­˜è¿›ä¸€ä¸ªå˜é‡ã€‚
            println!("===========2===========")
        },
        Message::Hello { id } => {
            println!("===========3=============");
        },
    }

}
```






ç¬¬19ç«    Rusté«˜çº§ç‰¹æ€§

æœ¬ç« å†…å®¹:
- ä¸å®‰å…¨Rust :  ç”¨äºå½“éœ€è¦èˆå¼ƒRustçš„æŸäº›ä¿è¯å¹¶æ‰‹åŠ¨ç»´æŒè¿™äº›ä¿è¯
- é«˜çº§trait: ä¸traitç›¸å…³çš„å…³è”ç±»å‹, é»˜è®¤ç±»å‹å‚æ•°, 
    å®Œå…¨é™å®šè¯­æ³•(fully qualified syntax), 
    è¶…(çˆ¶) trait (supertraits)å’Œ nwetype

- é«˜çº§ç±»å‹: å…³äºnewtypeæ¨¡å¼çš„æ›´å¤šå†…å®¹, ç±»å‹åˆ«å, neverç±»å‹å’ŒåŠ¨æ€å¤§å°ç±»å‹
- é«˜çº§å‡½æ•°å’Œé—­åŒ…: å‡½æ•°æŒ‡é’ˆå’Œè¿”å›é—­åŒ…
- å®: åœ¨ç¼–è¯‘æ—¶å®šä¹‰(å±•å¼€)æ›´å¤šä»£ç çš„æ–¹å¼





Rust è¿˜éšè—æœ‰ç¬¬äºŒç§è¯­è¨€ï¼Œå®ƒä¸ä¼šå¼ºåˆ¶æ‰§è¡Œè¿™ç±»å†…å­˜å®‰å…¨ä¿è¯ï¼šè¿™è¢«ç§°ä¸º ä¸å®‰å…¨ Rustï¼ˆunsafe Rustï¼‰

ä½¿ç”¨ä¸å®‰å…¨ä»£ç å¥½æ¯”å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œâ€œç›¸ä¿¡æˆ‘ï¼Œæˆ‘çŸ¥é“æˆ‘åœ¨å¹²ä»€ä¹ˆã€‚â€è¿™ä¹ˆåšçš„ç¼ºç‚¹å°±æ˜¯ä½ åªèƒ½é è‡ªå·±äº†ï¼š
å¦‚æœä¸å®‰å…¨ä»£ç å‡ºé”™äº†ï¼Œæ¯”å¦‚è§£å¼•ç”¨ç©ºæŒ‡é’ˆï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸å®‰å…¨çš„å†…å­˜ä½¿ç”¨ã€‚

å¦ä¸€ä¸ª Rust å­˜åœ¨ä¸å®‰å…¨ä¸€é¢çš„åŸå› æ˜¯ï¼šåº•å±‚è®¡ç®—æœºç¡¬ä»¶å›ºæœ‰çš„ä¸å®‰å…¨æ€§ã€‚

äº”ä¸ªè¶…èƒ½åŠ›:
- è§£å¼•ç”¨è£¸æŒ‡é’ˆ
- è°ƒç”¨ä¸å®‰å…¨çš„å‡½æ•°æˆ–æ–¹æ³•
- è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
- å®ç°ä¸å®‰å…¨trait
- è®¿é—®unionçš„å­—æ®µ



è£¸æŒ‡é’ˆ(raw pointers)

è£¸æŒ‡é’ˆä¹Ÿåˆ†ä¸º å¯å˜å’Œä¸å¯å˜:  *const T  å’Œ *mut T  ,   å…¶ä¸­æ˜Ÿå·ä¸æ˜¯è§£å¼•ç”¨è¿ç®—ç¬¦,å®ƒæ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†.

è£¸æŒ‡é’ˆä¸å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„åŒºåˆ«åœ¨äº:

- å…è®¸å¿½ç•¥å€Ÿç”¨è§„åˆ™, å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸å¯å˜å’Œå¯å˜çš„æŒ‡é’ˆ, æˆ–å¤šä¸ªæŒ‡å‘ç›¸åŒä½ç½®çš„å¯å˜æŒ‡é’ˆ
- ä¸ä¿è¯æŒ‡å‘æœ‰æ•ˆçš„å†…å­˜
- å…è®¸ä¸ºç©º
- ä¸èƒ½å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†åŠŸèƒ½


è£¸æŒ‡é’ˆçš„åº”ç”¨åœºæ™¯:
- ä¸€ä¸ªä¸»è¦çš„åº”ç”¨åœºæ™¯ä¾¿æ˜¯è°ƒç”¨ C ä»£ç æ¥å£
- å¦ä¸€ä¸ªåœºæ™¯æ˜¯æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡

ä½¿ç”¨ extern å‡½æ•°è°ƒç”¨å¤–éƒ¨ä»£ç 

```rust

//ä½¿ç”¨ C ä¸­çš„å‡½æ•°
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```



è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```


å®ç°ä¸å®‰å…¨ trait


è®¿é—®è”åˆä½“ä¸­çš„å­—æ®µ





é«˜çº§trait

å…³è”ç±»å‹(associate types) æ˜¯ä¸€ä¸ªè€Œå°†ç±»å‹å ä½ç¬¦ä¸traitç›¸å…³è”çš„æ–¹å¼, è¿™æ ·traitçš„æ–¹æ³•ç­¾åä¸­å°±å¯ä»¥ä½¿ç”¨è¿™äº›å ä½ç¬¦ç±»å‹.


ä¸ºä»€ä¹ˆä¸é€‚ç”¨æ³›å‹è€Œä½¿ç”¨å…³è”ç±»å‹?  å› ä¸ºå…³è”ç±»å‹åªèƒ½å®ç°ä¸€æ¬¡, æ³›å‹å¯ä»¥å¤šæ¬¡(ä¸åŒ)å®ç°trait




é»˜è®¤æ³›å‹ç±»å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½


```rust
trait Add<RHS=Self> { //é»˜è®¤å‚æ•°ç±»å‹
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}

```


å®Œå…¨é™å®šè¯­æ³•


```rust

let person  = Human;
person.fly();
Pilot::fly(&person);
Wizard::fly(&person);

 println!("a bady dog is called a {}", <Dog as Animal>::baby_name());


```




çˆ¶traitç”¨äºåœ¨å¦ä¸€ä¸ªtraitä¸­ä½¿ç”¨æŸtraitçš„åŠŸèƒ½

```rust


// å®ç°  supertrait
trait OutlinePrint: fmt::Display { // ç›¸å½“äºä¸º trait å¢åŠ  trait bound
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

```


newtype æ¨¡å¼ç”¨ä»¥åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨trait


```rust


use std::fmt;

/*
åªè¦ trait æˆ–ç±»å‹å¯¹äºå½“å‰ crate æ˜¯æœ¬åœ°çš„è¯å°±å¯ä»¥åœ¨æ­¤ç±»å‹ä¸Šå®ç°è¯¥
 traitã€‚ä¸€ä¸ªç»•å¼€è¿™ä¸ªé™åˆ¶çš„æ–¹æ³•æ˜¯ä½¿ç”¨ newtype æ¨¡å¼ï¼ˆnewtype patternï¼‰ï¼Œå®ƒæ¶‰åŠåˆ°åœ¨ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“ï¼ˆç¬¬äº”ç«  â€œç”¨æ²¡æœ‰å‘½åå­—æ®µçš„å…ƒç»„
ç»“æ„ä½“æ¥åˆ›å»ºä¸åŒçš„ç±»å‹â€ éƒ¨åˆ†ä»‹ç»äº†å…ƒç»„ç»“æ„ä½“ï¼‰ä¸­åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹ã€‚
*/

// newtype æ¨¡å¼
// æ²¡æœ‰è¿è¡Œæ—¶æ¶ˆè€—
struct Wrapper(Vec<String>);


impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter ) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))  // æ‹¼æ¥ 
    }
}

/*
// error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
impl fmt::Display for Vec<String> {
    fn fmt(&self, f: &mut fmt::Formatter ) -> fmt::Result {
        write!(f, "hello world")  
    } 
}
*/


fn main() {

    let w = Wrapper(vec![
            String::from("hello"),
            String::from("world"),
            String::from("newboy"),
            ]);

    println!("w = {}", w);

}

```





é«˜çº§ç±»å‹

- ä½¿ç”¨ newtypeå¯ä»¥è®©ç±»å‹åæˆ–å‚æ•°ç±»å‹å¯è¯»æ€§æ›´å¥½, ä¸å®¹æ˜“æ··æ·†
- éšè—å®ç°ç»†èŠ‚
- éšè—å†…éƒ¨æ³›å‹ç±»å‹



ç±»å‹åˆ«å

ç±»ä¼¼Cä¸­çš„ typedef 


```rust
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;


// å¼•å…¥ç±»å‹åˆ«å Thunk æ¥å‡å°‘é‡å¤
type Thunk = Box<dyn Fn() + Send + 'static>;
fn takes_long_type(f: Thunk) {
    // --snip--
}



//ç±»å‹åˆ«åä¹Ÿç»å¸¸ä¸ Result<T, E> ç»“åˆä½¿ç”¨æ¥å‡å°‘é‡å¤
type Result<T> = std::result::Result<T, std::io::Error>;

```




ä»ä¸è¿”å›çš„never type
 
```rust
// bar ä¹Ÿç§° å‘æ•£å‡½æ•°ï¼ˆdiverging functionsï¼‰
fn bar() -> ! {
    // --snip--
}
```



```rust

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
//continue çš„å€¼æ˜¯ !ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ Rust è¦è®¡ç®— guess çš„ç±»å‹æ—¶ï¼Œå®ƒæŸ¥çœ‹è¿™ä¸¤ä¸ªåˆ†æ”¯ã€‚å‰è€…æ˜¯ u32 å€¼ï¼Œè€Œåè€…æ˜¯ ! å€¼ã€‚å› ä¸º ! å¹¶æ²¡æœ‰ä¸€ä¸ªå€¼ï¼ŒRust å†³å®š guess çš„ç±»å‹æ˜¯ u32ã€‚

```



```rust
let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello", // ERROR!!
}
```




åŠ¨æ€å¤§å°ç±»å‹(DST  dynamically sized types) å’Œ Sized trait

è§„åˆ™: å¿…é¡»å°†åŠ¨æ€å¤§å°ç±»å‹çš„å€¼ç½®äºæŸç§æŒ‡é’ˆä¹‹å






é«˜çº§å‡½æ•°ä¸é—­åŒ…

å‡½æ•°æŒ‡é’ˆ

```rust


fn add_one(x: i32) -> i32 {
    x + 1
}


// å‡½æ•°æŒ‡é’ˆ
type fnt = fn(i32) -> i32;

fn add_twice(fun: fnt, arg: i32 ) -> i32 {
    fun(arg) + fun(arg)
}


fn main() {

    let a = add_twice(add_one, 5);
    println!("a = {}", a);

}

```




è¿”å›é—­åŒ…

```rust

// Fn(i32) -> i32
// doesn't have a size known at compile-time
// the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -> i32 + 'static)`
//fn return_closure() -> Fn(i32) -> i32 {
//    |x| x + 1
//}



fn return_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new( |x| x + 1 )
}

fn main() {

    let cls = return_closure();

    println!("{}", cls(666));

}
```




å®

- å£°æ˜ï¼ˆDeclarativeï¼‰å®
- macro_rules!
- 3ç§è¿‡ç¨‹(Procedural)å®
    - è‡ªå®šä¹‰ `#[derive]` å®åœ¨ç»“æ„ä½“å’Œæšä¸¾ä¸ŠæŒ‡å®šé€šè¿‡ derive å±æ€§æ·»åŠ çš„ä»£ç 
    - ç±»å±æ€§ï¼ˆAttributeï¼‰å®å®šä¹‰å¯ç”¨äºä»»æ„é¡¹çš„è‡ªå®šä¹‰å±æ€§
    - ç±»å‡½æ•°å®çœ‹èµ·æ¥åƒå‡½æ•°ä¸è¿‡ä½œç”¨äºä½œä¸ºå‚æ•°ä¼ é€’çš„ token



å®å’Œå‡½æ•°çš„åŒºåˆ«
- å®åœ¨ç¼–è¯‘æ—¶æœŸå±•å¼€ 
- å®å¯ä»¥åœ¨ç»™å®šç±»å‹ä¸Šå®ç°trait , å‡½æ•°ä¸è¡Œ
- å®çš„å¯è¯»æ€§ä¸å¥½
- åœ¨è°ƒç”¨å® ä¹‹å‰ å¿…é¡»å®šä¹‰å¹¶å°†å…¶å¼•å…¥ä½œç”¨åŸŸï¼Œè€Œå‡½æ•°åˆ™å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹å®šä¹‰å’Œè°ƒç”¨ã€‚



vec! å®å±•å¼€

```rust

#[macro_export]   // å¯ä»¥è¢«å¯¼å…¥ä½œç”¨åŸŸ
macro_rules! vec {
    ( $( $x:expr ),* ) => {  //å•è¾¹æ¨¡å¼, æ¨¡å¼åŒ¹é…, åŒ¹é…æˆåŠŸåˆ™æ‰§è¡Œä¸‹é¢ä»£ç 
    // $() å†…åˆ™æ˜¯ $x:expr ï¼Œå…¶åŒ¹é… Rust çš„ä»»æ„è¡¨è¾¾å¼æˆ–ç»™å®š $x åå­—çš„è¡¨è¾¾å¼ã€‚
    // ç´§éšé€—å·ä¹‹åçš„ * è¯´æ˜è¯¥æ¨¡å¼åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ª * ä¹‹å‰çš„ä»»ä½•æ¨¡å¼
    // ä»¥ vec![1, 2, 3]; è°ƒç”¨å®æ—¶ï¼Œ$x æ¨¡å¼ä¸ä¸‰ä¸ªè¡¨è¾¾å¼ 1ã€2 å’Œ 3 è¿›è¡Œäº†ä¸‰æ¬¡åŒ¹é…ã€‚
        { 
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

```

å¦‚æœ `vec![1, 2, 3]` å±•å¼€ä¹‹å:

```rust
let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec

```




derive åªèƒ½ç”¨äºç»“æ„ä½“å’Œæšä¸¾ï¼›


ç±»å±æ€§å®

```rust

#[route(GET, "/")]
fn index() {
}

```


ç±»å‡½æ•°å®

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```



ç¬¬ 20 ç«    æ„å»ºå¤šçº¿ç¨‹ web server



```rust

impl Drop for ThreadPool {

    /// è¿™é‡Œä¸ºä»€ä¹ˆä½¿ç”¨ä¸¤ä¸ªå¾ªç¯,è€Œä¸ä½¿ç”¨ä¸€ä¸ªå¾ªç¯?
    /// å¦‚æœä½¿ç”¨ä¸€ä¸ªå¾ªç¯, å³å‘é€äº†Terminateæ¶ˆæ¯ä¹‹å, join() ç­‰å¾…å½“å‰è¢«è¿­ä»£çš„workeré€€å‡º
    /// ä½†æ˜¯, å¹¶ä¸èƒ½ä¿è¯ Terminateæ¶ˆæ¯è¢«å½“å‰Workeræ”¶åˆ°, 
    /// å¦‚æœ è¢«å…¶ä»–Workeræ”¶åˆ°, è€Œå½“å‰è¿­ä»£çš„workeræ²¡æœ‰æ”¶åˆ°, é‚£ä¹ˆå°±æ˜¯ä¸€ç›´ç­‰ä¸‹å»!  é€ æˆæ­»é”
    /// 
    /// æ‰€ä»¥, åˆ†æˆä¸¤ä¸ªå¾ªç¯, ä¸€ä¸ªå¾ªç¯å•ç‹¬å‘é€æ¶ˆæ¯ , å‘é€å®Œäº†ä¹‹å, å¦ä¸€ä¸ªå¾ªç¯ å†joinç­‰å¾…workeré€€å‡º
    /// è¿™æ ·å°±èƒ½ä¿è¯,  åœ¨joinå‰å‰, æ¯ä¸ªworkeréƒ½æ”¶åˆ°äº† Terminateæ¶ˆæ¯, 
    fn drop(&mut self) {

        // å‘é€é€€å‡ºæ¶ˆæ¯
        println!("Sending terminate message to all workers.");
        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }
        println!("Shutting down all workers.");


        // ç­‰å¾…æ¯ä¸ªworkerçº¿ç¨‹é€€å‡º
        for worker in &mut self.workers {
            println!("shutting down worker {}", worker.id);

            // ä½¿ç”¨ if let è§£æ„ Some å¹¶å¾—åˆ°çº¿ç¨‹ï¼Œæ¥ç€åœ¨çº¿ç¨‹ä¸Šè°ƒç”¨ joinã€‚
            // å¦‚æœ worker çš„çº¿ç¨‹å·²ç„¶æ˜¯ Noneï¼Œå°±çŸ¥é“æ­¤æ—¶è¿™ä¸ª worker å·²ç»æ¸…ç†äº†å…¶çº¿ç¨‹æ‰€ä»¥æ— éœ€åšä»»ä½•æ“ä½œã€‚
            // worker.thread.join().unwrap();
            if let Some(thread)  = worker.thread.take() {
                thread.join().unwrap();
            }

            // è¿™ç§æ–¹å¼å­˜åœ¨é—®é¢˜, å³ å¦‚æœä¸€ä¸ªçº¿ç¨‹å·²ç»æ˜¯None, å†è°ƒç”¨ joinæ–¹æ³•å°±ä¼š panic
            // worker.thread.take().unwrap().join().unwrap();
        }

    }
}
```


å®Œå–„ webserver:

- ä¸º ThreadPool å’Œå…¶å…¬æœ‰æ–¹æ³•å¢åŠ æ›´å¤šæ–‡æ¡£
- ä¸ºåº“çš„åŠŸèƒ½å¢åŠ æµ‹è¯•
- å°† unwrap è°ƒç”¨æ”¹ä¸ºæ›´å¥å£®çš„é”™è¯¯å¤„ç†
- ä½¿ç”¨ ThreadPool è¿›è¡Œå…¶ä»–ä¸åŒäºå¤„ç†ç½‘ç»œè¯·æ±‚çš„ä»»åŠ¡
- åœ¨ crates.io ä¸Šå¯»æ‰¾ä¸€ä¸ªçº¿ç¨‹æ±  crate å¹¶ä½¿ç”¨å®ƒå®ç°ä¸€ä¸ªç±»ä¼¼çš„ web serverï¼Œå°†å…¶ API å’Œé²æ£’æ€§ä¸æˆ‘ä»¬çš„å®ç°åšå¯¹æ¯”